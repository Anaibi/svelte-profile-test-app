var app = (function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function reinsertBetween(before, after, target) {
		while (before.nextSibling && before.nextSibling !== after) {
			target.appendChild(before.parentNode.removeChild(before.nextSibling));
		}
	}

	function reinsertChildren(parent, target) {
		while (parent.firstChild) target.appendChild(parent.firstChild);
	}

	function destroyEach(iterations) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d();
		}
	}

	function createFragment() {
		return document.createDocumentFragment();
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createSvgElement(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		if (detach !== false) this._fragment.u();
		this._fragment.d();
		this._fragment = null;
		this._state = {};
	}

	function destroyDev(detach) {
		destroy.call(this, detach);
		this.destroy = function() {
			console.warn('Component was already destroyed');
		};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				handler.__calling = true;
				handler.call(this, data);
				handler.__calling = false;
			}
		}
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._bind = options._bind;

		component.options = options;
		component.root = options.root || component;
		component.store = component.root.store || options.store;
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		this.root._lock = true;
		callAll(this.root._beforecreate);
		callAll(this.root._oncreate);
		callAll(this.root._aftercreate);
		this.root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function setDev(newState) {
		if (typeof newState !== 'object') {
			throw new Error(
				this._debugName + '.set was called without an object of data key-values to update.'
			);
		}

		this._checkReadOnly(newState);
		set.call(this, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	function _unmount() {
		if (this._fragment) this._fragment.u();
	}

	function isPromise(value) {
		return value && typeof value.then === 'function';
	}

	var protoDev = {
		destroy: destroyDev,
		get,
		fire,
		on,
		set: setDev,
		_recompute: noop,
		_set,
		_mount,
		_unmount,
		_differs
	};

	/* src/icons/SVG_Search.html generated by Svelte v2.4.4 */

	function create_main_fragment(component, ctx) {
		var svg, path, path_1;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				path_1 = createSvgElement("path");
				setAttribute(path, "d", "M20,0c-6.627,0-12,5.373-12,12c0,2.026,0.507,3.933,1.395,5.608L1.052,25.95l0.007,0.006 c-0.652,0.641-1.058,1.529-1.058,2.516c0,1.949,1.58,3.529,3.529,3.529c0.985,0,1.874-0.406,2.515-1.059L6.043,30.94l8.341-8.34 C16.059,23.491,17.969,24,20,24c6.627,0,12-5.373,12-12S26.628,0,20,0z M4.796,29.692c-0.322,0.334-0.768,0.543-1.266,0.543 c-0.975,0-1.765-0.789-1.765-1.764c0-0.498,0.21-0.943,0.543-1.266l-0.009-0.008l8.066-8.066c0.705,0.951,1.545,1.791,2.494,2.498 L4.796,29.692z M20,22.001c-5.522,0-10-4.479-10-10c0-5.522,4.478-10,10-10c5.521,0,10,4.478,10,10 C30,17.522,25.521,22.001,20,22.001z");
				setAttribute(path_1, "d", "M20,5c-3.867,0-7,3.134-7,7c0,0.276,0.224,0.5,0.5,0.5s0.5-0.224,0.5-0.5c0-3.313,2.686-6,6-6 c0.275,0,0.5-0.224,0.5-0.5S20.275,5,20,5z");
				setAttribute(svg, "viewBox", "0 0 32.001 32.001");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(path_1, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Search(options) {
		this._debugName = '<SVG_Search>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Search.prototype, protoDev);

	SVG_Search.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Edit.html generated by Svelte v2.4.4 */

	function create_main_fragment$1(component, ctx) {
		var svg, path, path_1;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				path_1 = createSvgElement("path");
				setAttribute(path, "d", "M36.573,309.292h2.09l100.833-21.943c1.964-0.327,3.784-1.237,5.224-2.612L315.56,113.896 c12.48-12.453,19.443-29.391,19.331-47.02c0.023-17.766-6.917-34.833-19.331-47.543C303.108,6.853,286.17-0.11,268.54,0.003 c-17.742-0.157-34.76,7.028-47.02,19.853L51.201,190.696c-1.502,1.209-2.597,2.85-3.135,4.702L26.124,296.231 c-0.599,3.62,0.565,7.308,3.135,9.927C31.188,308.126,33.817,309.253,36.573,309.292z M268.54,20.901 c25.103-0.002,45.454,20.347,45.456,45.45c0,0.175-0.001,0.35-0.003,0.525c0.171,11.959-4.547,23.47-13.061,31.869 l-64.261-64.784C245.137,25.548,256.604,20.848,268.54,20.901z M222.042,49.113l64.261,64.261L137.405,261.749l-64.261-63.739 L222.042,49.113z M64.785,218.909l51.722,51.722L50.156,285.26L64.785,218.909z");
				setAttribute(path_1, "d", "M368.328,365.717H18.287c-5.771,0-10.449,4.678-10.449,10.449s4.678,10.449,10.449,10.449h350.041 c5.771,0,10.449-4.678,10.449-10.449S374.099,365.717,368.328,365.717z");
				setAttribute(svg, "viewBox", "0 0 386.615 386.615");
				setAttribute(svg, "fill", "CurrentColor");
				setAttribute(svg, "stroke", "none");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(path_1, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Edit(options) {
		this._debugName = '<SVG_Edit>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$1(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Edit.prototype, protoDev);

	SVG_Edit.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Message.html generated by Svelte v2.4.4 */

	function create_main_fragment$2(component, ctx) {
		var svg, path, g, circle, circle_1;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				g = createSvgElement("g");
				circle = createSvgElement("circle");
				circle_1 = createSvgElement("circle");
				setAttribute(path, "d", "M8.3 1c-4.4 0-8.3 2.6-8.3 5.6 0 2 1.1 3.7 3 4.7 0 0 0 0 0 0s0 0.1 0 0.1c-0.1 1.3-0.9 1.7-0.9 1.7l-1.8 0.9h2c2.5 0 4.3-1.1 5.1-1.9 0.3 0 0.5 0 0.8 0 4.3 0 7.8-2.5 7.8-5.6s-3.4-5.5-7.7-5.5zM8.2 11.1c-0.3 0-0.7 0-0.9 0h-0.3l-0.2 0.2c-0.5 0.5-1.6 1.4-3.3 1.7 0.3-0.5 0.5-1.1 0.5-2v-0.3l-0.3-0.1c-1.8-0.9-2.7-2.3-2.7-4 0-2.4 3.5-4.6 7.3-4.6 3.7 0 6.7 2 6.7 4.6 0 2.4-3.1 4.5-6.8 4.5z");
				setStyle(circle, "stroke", "var(--bg, white)");
				setStyle(circle, "fill", "none");
				setAttribute(circle, "r", "3");
				setAttribute(circle, "cy", "3");
				setAttribute(circle, "cx", "13");
				setStyle(circle_1, "stroke", "CurrentColor");
				setStyle(circle_1, "fill", "var(--bg, white)");
				setAttribute(circle_1, "r", "2");
				setAttribute(circle_1, "cy", "3");
				setAttribute(circle_1, "cx", "13");
				setAttribute(g, "class", "active");
				setAttribute(svg, "viewBox", "0 0 16 16");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(g, svg);
				appendNode(circle, g);
				appendNode(circle_1, g);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Message(options) {
		this._debugName = '<SVG_Message>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$2(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Message.prototype, protoDev);

	SVG_Message.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Agenda.html generated by Svelte v2.4.4 */

	function create_main_fragment$3(component, ctx) {
		var svg, path, path_1, path_2, path_3;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				path_1 = createSvgElement("path");
				path_2 = createSvgElement("path");
				path_3 = createSvgElement("path");
				setAttribute(path, "d", "M589.328,90.508H534.97v-36.3C534.971,24.317,510.655,0,480.765,0c-29.889,0-54.205,24.317-54.205,54.208v36.3h-66.358 v-36.3C360.203,24.317,335.888,0,305.998,0c-29.888,0-54.205,24.317-54.205,54.208v36.3h-66.356v-36.3 C185.439,24.317,161.121,0,131.233,0S77.029,24.317,77.029,54.208v36.3H22.67c-10.195,0-18.458,8.265-18.458,18.458V537.12 c0,41.29,33.59,74.88,74.881,74.88h453.814c41.29,0,74.881-33.59,74.881-74.88V108.966 C607.786,98.773,599.525,90.508,589.328,90.508z M570.87,207.023H41.128v-79.6H77.03v9.349c0,29.889,24.317,54.205,54.203,54.205 c29.888,0,54.206-24.317,54.206-54.205v-9.349h66.356v9.349c0,29.889,24.317,54.205,54.205,54.205 c29.889,0,54.205-24.317,54.205-54.205v-9.349h66.358v9.349c0,29.889,24.317,54.205,54.205,54.205 c29.889,0,54.205-24.317,54.205-54.205v-9.349h35.901v79.6H570.87z M463.476,54.208c0-9.535,7.754-17.292,17.289-17.292 c9.532,0,17.289,7.757,17.289,17.292v82.565c0,9.532-7.757,17.289-17.289,17.289c-9.535,0-17.289-7.757-17.289-17.289V54.208z M288.711,54.208c0-9.535,7.755-17.292,17.289-17.292c9.532,0,17.289,7.757,17.289,17.292v54.743c0,0.003,0,0.009,0,0.015 c0,0.003,0,0.009,0,0.015v27.791c0,9.532-7.757,17.289-17.289,17.289c-9.534,0-17.289-7.757-17.289-17.289V54.208z M113.944,54.208c0-9.535,7.755-17.292,17.289-17.292c9.535,0,17.29,7.757,17.29,17.292v54.728c0,0.009-0.002,0.018-0.002,0.029 c0,0.009,0.002,0.018,0.002,0.031v27.778c0,9.532-7.755,17.289-17.29,17.289c-9.532,0-17.287-7.757-17.287-17.289V54.208H113.944 z M570.87,537.119c0,20.933-17.03,37.965-37.965,37.965H79.091c-20.933,0-37.965-17.03-37.965-37.965V243.936H570.87V537.119z");
				setAttribute(path_1, "d", "M95.486,334.921h421.026c10.193,0,18.458-8.264,18.458-18.458s-8.265-18.458-18.458-18.458H95.486 c-10.195,0-18.458,8.265-18.458,18.458S85.292,334.921,95.486,334.921z");
				setAttribute(path_2, "d", "M95.486,420.496h421.026c10.193,0,18.458-8.264,18.458-18.458c0-10.193-8.265-18.458-18.458-18.458H95.486 c-10.195,0-18.458,8.265-18.458,18.458C77.029,412.232,85.292,420.496,95.486,420.496z");
				setAttribute(path_3, "d", "M95.486,506.072h421.026c10.193,0,18.458-8.264,18.458-18.458c0-10.193-8.265-18.458-18.458-18.458H95.486 c-10.195,0-18.458,8.264-18.458,18.458C77.029,497.807,85.292,506.072,95.486,506.072z");
				setAttribute(svg, "viewBox", "0 0 612 612");
				setAttribute(svg, "fill", "CurrentColor");
				setAttribute(svg, "stroke", "none");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(path_1, svg);
				appendNode(path_2, svg);
				appendNode(path_3, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Agenda(options) {
		this._debugName = '<SVG_Agenda>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$3(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Agenda.prototype, protoDev);

	SVG_Agenda.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Clipboard.html generated by Svelte v2.4.4 */

	function create_main_fragment$4(component, ctx) {
		var svg, path, circle, path_1, circle_1, path_2, circle_2, path_3;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				circle = createSvgElement("circle");
				path_1 = createSvgElement("path");
				circle_1 = createSvgElement("circle");
				path_2 = createSvgElement("path");
				circle_2 = createSvgElement("circle");
				path_3 = createSvgElement("path");
				setAttribute(path, "d", "M422.957,33.391h-52.959C363.106,13.959,344.548,0,322.783,0H189.217c-21.766,0-40.323,13.959-47.215,33.391H89.044 c-27.618,0-50.087,22.469-50.087,50.087v378.435c0,27.618,22.469,50.087,50.087,50.087h333.913 c27.618,0,50.087-22.469,50.087-50.087V83.478C473.043,55.86,450.574,33.391,422.957,33.391z M172.522,50.087 c0-9.206,7.49-16.696,16.696-16.696h133.565c9.206,0,16.696,7.49,16.696,16.696v16.696H172.522V50.087z M439.652,461.913 c0,9.206-7.49,16.696-16.696,16.696H89.044c-9.206,0-16.696-7.49-16.696-16.696V83.478c0-9.206,7.49-16.696,16.696-16.696h50.087 v16.696c0,9.22,7.475,16.696,16.696,16.696h200.348c9.22,0,16.696-7.475,16.696-16.696V66.783h50.087 c9.206,0,16.696,7.49,16.696,16.696V461.913z");
				setAttribute(circle, "cx", "122.435");
				setAttribute(circle, "cy", "183.652");
				setAttribute(circle, "r", "16.696");
				setAttribute(path_1, "d", "M389.565,166.957H189.217c-9.22,0-16.696,7.475-16.696,16.696c0,9.22,7.475,16.696,16.696,16.696h200.348 c9.22,0,16.696-7.475,16.696-16.696C406.261,174.432,398.786,166.957,389.565,166.957z");
				setAttribute(circle_1, "cx", "122.435");
				setAttribute(circle_1, "cy", "283.826");
				setAttribute(circle_1, "r", "16.696");
				setAttribute(path_2, "d", "M389.565,267.13H189.217c-9.22,0-16.696,7.475-16.696,16.696c0,9.22,7.475,16.696,16.696,16.696h200.348 c9.22,0,16.696-7.475,16.696-16.696C406.261,274.606,398.786,267.13,389.565,267.13z");
				setAttribute(circle_2, "cx", "122.435");
				setAttribute(circle_2, "cy", "384");
				setAttribute(circle_2, "r", "16.696");
				setAttribute(path_3, "d", "M389.565,367.304H189.217c-9.22,0-16.696,7.475-16.696,16.696s7.475,16.696,16.696,16.696h200.348 c9.22,0,16.696-7.475,16.696-16.696S398.786,367.304,389.565,367.304z");
				setAttribute(svg, "viewBox", "0 0 512 512");
				setAttribute(svg, "fill", "CurrentColor");
				setAttribute(svg, "stroke", "none");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(circle, svg);
				appendNode(path_1, svg);
				appendNode(circle_1, svg);
				appendNode(path_2, svg);
				appendNode(circle_2, svg);
				appendNode(path_3, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Clipboard(options) {
		this._debugName = '<SVG_Clipboard>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$4(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Clipboard.prototype, protoDev);

	SVG_Clipboard.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Clip.html generated by Svelte v2.4.4 */

	function create_main_fragment$5(component, ctx) {
		var svg, path;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				setAttribute(path, "d", "M26.834,98.371c-6.574,0-12.727-2.789-17.17-7.232C1.055,82.53-1.345,67.5,10.725,55.43 c7.072-7.072,35.4-35.398,49.541-49.542c5.02-5.02,11.41-6.958,17.527-5.319C83.801,2.178,88.725,7.1,90.334,13.107 c1.639,6.121-0.299,12.509-5.318,17.529L37.639,78.014c-2.705,2.705-5.76,4.306-8.832,4.631c-3.041,0.32-5.945-0.659-7.977-2.69 c-3.686-3.685-4.211-10.621,1.916-16.745l33.278-33.28c1.367-1.367,3.582-1.367,4.949,0s1.367,3.583,0,4.949L27.696,68.158 c-2.877,2.876-3.141,5.622-1.916,6.847c0.537,0.537,1.352,0.779,2.291,0.678c1.441-0.152,3.082-1.083,4.619-2.62l47.377-47.376 c3.25-3.25,4.496-7.074,3.506-10.766c-0.975-3.637-3.953-6.615-7.59-7.59c-3.691-0.99-7.516,0.256-10.768,3.507 c-14.14,14.141-42.469,42.471-49.541,49.541c-9.23,9.23-7.02,19.85-1.061,25.809s16.578,8.171,25.811-1.06l49.541-49.542 c1.367-1.367,3.582-1.367,4.949,0s1.367,3.583,0,4.949L45.373,90.078C39.534,95.919,32.998,98.371,26.834,98.371z");
				setAttribute(svg, "viewBox", "0 0 98.371 98.371");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Clip(options) {
		this._debugName = '<SVG_Clip>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$5(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Clip.prototype, protoDev);

	SVG_Clip.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_UserAdd.html generated by Svelte v2.4.4 */

	function create_main_fragment$6(component, ctx) {
		var svg, path, polygon;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				polygon = createSvgElement("polygon");
				setAttribute(path, "d", "M255.501,0.499c-81.448,0-147.711,66.264-147.711,147.711c0,50.449,25.429,95.065,64.137,121.724 c-36.139,12.471-69.263,33.071-97.091,60.899C26.577,379.093,0,443.254,0,511.501h39.922 c0-118.871,96.708-215.579,215.579-215.579c81.448,0,147.711-66.264,147.711-147.712S336.949,0.499,255.501,0.499z M255.501,256 c-59.435,0-107.789-48.354-107.789-107.789S196.066,40.421,255.501,40.421S363.29,88.775,363.29,148.211S314.936,256,255.501,256z");
				setAttribute(polygon, "points", "428.164,387.743 428.164,303.906 388.242,303.906 388.242,387.743 304.405,387.743 304.405,427.665 388.242,427.665 388.242,511.501 428.164,511.501 428.164,427.665 512,427.665 512,387.743 \t\t");
				setAttribute(svg, "viewBox", "0 0 512 512");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(polygon, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_UserAdd(options) {
		this._debugName = '<SVG_UserAdd>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$6(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_UserAdd.prototype, protoDev);

	SVG_UserAdd.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Camera.html generated by Svelte v2.4.4 */

	function create_main_fragment$7(component, ctx) {
		var svg, path, path_1, circle;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				path_1 = createSvgElement("path");
				circle = createSvgElement("circle");
				setAttribute(path, "d", "M406.8,96.4c-8.4-8.8-20-14-33.2-14h-66.4v-0.8c0-10-4-19.6-10.8-26c-6.8-6.8-16-10.8-26-10.8h-120 c-10.4,0-19.6,4-26.4,10.8c-6.8,6.8-10.8,16-10.8,26v0.8h-66c-13.2,0-24.8,5.2-33.2,14c-8.4,8.4-14,20.4-14,33.2v199.2 C0,342,5.2,353.6,14,362c8.4,8.4,20.4,14,33.2,14h326.4c13.2,0,24.8-5.2,33.2-14c8.4-8.4,14-20.4,14-33.2V129.6 C420.8,116.4,415.6,104.8,406.8,96.4z M400,328.8h-0.4c0,7.2-2.8,13.6-7.6,18.4s-11.2,7.6-18.4,7.6H47.2 c-7.2,0-13.6-2.8-18.4-7.6c-4.8-4.8-7.6-11.2-7.6-18.4V129.6c0-7.2,2.8-13.6,7.6-18.4s11.2-7.6,18.4-7.6h77.2 c6,0,10.8-4.8,10.8-10.8V81.2c0-4.4,1.6-8.4,4.4-11.2s6.8-4.4,11.2-4.4h119.6c4.4,0,8.4,1.6,11.2,4.4c2.8,2.8,4.4,6.8,4.4,11.2 v11.6c0,6,4.8,10.8,10.8,10.8H374c7.2,0,13.6,2.8,18.4,7.6s7.6,11.2,7.6,18.4V328.8z");
				setAttribute(path_1, "d", "M210.4,130.8c-27.2,0-52,11.2-69.6,28.8c-18,18-28.8,42.4-28.8,69.6s11.2,52,28.8,69.6c18,18,42.4,28.8,69.6,28.8 s52-11.2,69.6-28.8c18-18,28.8-42.4,28.8-69.6s-11.2-52-28.8-69.6C262.4,142,237.6,130.8,210.4,130.8z M264.8,284 c-14,13.6-33.2,22.4-54.4,22.4S170,297.6,156,284c-14-14-22.4-33.2-22.4-54.4c0-21.2,8.8-40.4,22.4-54.4 c14-14,33.2-22.4,54.4-22.4s40.4,8.8,54.4,22.4c14,14,22.4,33.2,22.4,54.4C287.6,250.8,278.8,270,264.8,284z");
				setAttribute(circle, "cx", "352.8");
				setAttribute(circle, "cy", "150");
				setAttribute(circle, "r", "19.6");
				setAttribute(svg, "viewBox", "0 0 420.8 420.8");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(path_1, svg);
				appendNode(circle, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Camera(options) {
		this._debugName = '<SVG_Camera>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$7(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Camera.prototype, protoDev);

	SVG_Camera.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Star.html generated by Svelte v2.4.4 */

	function create_main_fragment$8(component, ctx) {
		var svg, polygon;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				polygon = createSvgElement("polygon");
				setAttribute(polygon, "points", "26.934,1.318 35.256,18.182 53.867,20.887 40.4,34.013 43.579,52.549 26.934,43.798 10.288,52.549 13.467,34.013 0,20.887 18.611,18.182 ");
				setAttribute(svg, "viewBox", "-3 -2 60 58");
				setAttribute(svg, "stroke", "currentColor");
				setAttribute(svg, "fill", "none");
				setAttribute(svg, "stroke-width", "5");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(polygon, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Star(options) {
		this._debugName = '<SVG_Star>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$8(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Star.prototype, protoDev);

	SVG_Star.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Book.html generated by Svelte v2.4.4 */

	function create_main_fragment$9(component, ctx) {
		var svg, path, rect, rect_1, rect_2, rect_3, rect_4, rect_5;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				rect = createSvgElement("rect");
				rect_1 = createSvgElement("rect");
				rect_2 = createSvgElement("rect");
				rect_3 = createSvgElement("rect");
				rect_4 = createSvgElement("rect");
				rect_5 = createSvgElement("rect");
				setAttribute(path, "d", "M0,45.29V466.71h512V45.29H0z M271.068,75.427h210.795v303.241H271.068V75.427z M30.137,75.427h210.794v303.241H30.137 V75.427z M481.863,436.574H30.137v-27.77h451.726V436.574z");
				setAttribute(rect, "x", "81.63");
				setAttribute(rect, "y", "139.931");
				setAttribute(rect, "width", "110.87");
				setAttribute(rect, "height", "30.14");
				setAttribute(rect_1, "x", "81.63");
				setAttribute(rect_1, "y", "212.501");
				setAttribute(rect_1, "width", "110.87");
				setAttribute(rect_1, "height", "30.14");
				setAttribute(rect_2, "x", "81.63");
				setAttribute(rect_2, "y", "285.061");
				setAttribute(rect_2, "width", "110.87");
				setAttribute(rect_2, "height", "30.14");
				setAttribute(rect_3, "x", "324.25");
				setAttribute(rect_3, "y", "139.931");
				setAttribute(rect_3, "width", "110.87");
				setAttribute(rect_3, "height", "30.14");
				setAttribute(rect_4, "x", "324.25");
				setAttribute(rect_4, "y", "212.501");
				setAttribute(rect_4, "width", "110.87");
				setAttribute(rect_4, "height", "30.14");
				setAttribute(rect_5, "x", "324.25");
				setAttribute(rect_5, "y", "285.061");
				setAttribute(rect_5, "width", "110.87");
				setAttribute(rect_5, "height", "30.14");
				setAttribute(svg, "xmlns", "http://www.w3.org/2000/svg");
				setAttribute(svg, "viewBox", "0 0 512 512");
				setAttribute(svg, "fill", "CurrentColor");
				setAttribute(svg, "stroke", "none");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(rect, svg);
				appendNode(rect_1, svg);
				appendNode(rect_2, svg);
				appendNode(rect_3, svg);
				appendNode(rect_4, svg);
				appendNode(rect_5, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Book(options) {
		this._debugName = '<SVG_Book>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$9(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Book.prototype, protoDev);

	SVG_Book.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Clock.html generated by Svelte v2.4.4 */

	function create_main_fragment$10(component, ctx) {
		var svg, path, path_1;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				path_1 = createSvgElement("path");
				setAttribute(path, "d", "M238.933,0C106.974,0,0,106.974,0,238.933s106.974,238.933,238.933,238.933s238.933-106.974,238.933-238.933 C477.726,107.033,370.834,0.141,238.933,0z M238.933,443.733c-113.108,0-204.8-91.692-204.8-204.8s91.692-204.8,204.8-204.8 s204.8,91.692,204.8,204.8C443.611,351.991,351.991,443.611,238.933,443.733z");
				setAttribute(path_1, "d", "M238.933,85.333c-9.426,0-17.067,7.641-17.067,17.067v119.467H102.4c-9.426,0-17.067,7.641-17.067,17.067 S92.974,256,102.4,256h136.533c9.426,0,17.067-7.641,17.067-17.067V102.4C256,92.974,248.359,85.333,238.933,85.333z");
				setAttribute(svg, "viewBox", "0 0 477.867 477.867");
				setAttribute(svg, "fill", "CurrentColor");
				setAttribute(svg, "stroke", "none");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(path_1, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Clock(options) {
		this._debugName = '<SVG_Clock>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$10(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Clock.prototype, protoDev);

	SVG_Clock.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_MessageFull.html generated by Svelte v2.4.4 */

	function create_main_fragment$11(component, ctx) {
		var svg, path;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				setAttribute(path, "d", "M24.211,22.802C27.734,20.839,30,17.776,30,14.334c0-5.925-6.715-10.729-15-10.729c-8.284,0-15,4.804-15,10.729 c0,5.926,6.716,10.729,15,10.729c1.702,0,3.338-0.204,4.863-0.577c5.156,3.801,8.724,0.752,8.724,0.752 C26.146,25.238,24.874,24.069,24.211,22.802z");
				setAttribute(svg, "viewBox", "0 0 30 30");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "currentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_MessageFull(options) {
		this._debugName = '<SVG_MessageFull>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$11(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_MessageFull.prototype, protoDev);

	SVG_MessageFull.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Reply.html generated by Svelte v2.4.4 */

	function create_main_fragment$12(component, ctx) {
		var svg, path;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				setStyle(path, "transform-origin", "center");
				setStyle(path, "transform", "rotateY(180deg)");
				setAttribute(path, "d", "M234.672,181.402V42.672c0-4.309-2.603-8.213-6.592-9.856c-4.011-1.664-8.576-0.725-11.627,2.304L3.12,248.453 c-4.16,4.16-4.16,10.923,0,15.083l213.333,213.333c2.048,2.048,4.779,3.136,7.552,3.136c1.365,0,2.752-0.256,4.075-0.811 c3.989-1.643,6.592-5.547,6.592-9.856V331.056c46.208,2.304,226.496,17.835,256.427,119.957c1.493,5.099,6.549,8.384,11.755,7.552 c5.248-0.747,9.152-5.248,9.152-10.56C512.005,203.29,284.635,182.917,234.672,181.402z");
				setAttribute(svg, "viewBox", "0 0 512.005 512.005");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Reply(options) {
		this._debugName = '<SVG_Reply>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$12(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Reply.prototype, protoDev);

	SVG_Reply.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_More.html generated by Svelte v2.4.4 */

	function create_main_fragment$13(component, ctx) {
		var svg, path, path_1, path_2;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				path_1 = createSvgElement("path");
				path_2 = createSvgElement("path");
				setAttribute(path, "d", "M8,22c-4.411,0-8,3.589-8,8s3.589,8,8,8s8-3.589,8-8S12.411,22,8,22z");
				setAttribute(path_1, "d", "M52,22c-4.411,0-8,3.589-8,8s3.589,8,8,8s8-3.589,8-8S56.411,22,52,22z");
				setAttribute(path_2, "d", "M30,22c-4.411,0-8,3.589-8,8s3.589,8,8,8s8-3.589,8-8S34.411,22,30,22z");
				setAttribute(svg, "viewBox", "0 0 60 60");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
				appendNode(path_1, svg);
				appendNode(path_2, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_More(options) {
		this._debugName = '<SVG_More>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$13(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_More.prototype, protoDev);

	SVG_More.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/SVG_Bookmark.html generated by Svelte v2.4.4 */

	function create_main_fragment$14(component, ctx) {
		var svg, path;

		return {
			c: function create() {
				svg = createSvgElement("svg");
				path = createSvgElement("path");
				setAttribute(path, "d", "M38,0H8v46l15-12l15,12L38,0z M23,29l-11,9l0-34h22l0,34L23,29z");
				setAttribute(svg, "viewBox", "0 0 46 46");
				setAttribute(svg, "stroke", "none");
				setAttribute(svg, "fill", "CurrentColor");
			},

			m: function mount(target, anchor) {
				insertNode(svg, target, anchor);
				appendNode(path, svg);
			},

			p: noop,

			u: function unmount() {
				detachNode(svg);
			},

			d: noop
		};
	}

	function SVG_Bookmark(options) {
		this._debugName = '<SVG_Bookmark>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$14(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SVG_Bookmark.prototype, protoDev);

	SVG_Bookmark.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/icons/IconsSvg.html generated by Svelte v2.4.4 */

	var icons = {
		Search: SVG_Search,
		Edit: SVG_Edit,
		Message: SVG_Message,
		Agenda: SVG_Agenda,
		Clipboard: SVG_Clipboard,
		Clip: SVG_Clip,
		UserAdd: SVG_UserAdd,
		Camera: SVG_Camera,
		Star: SVG_Star,
		Book: SVG_Book,
		Clock: SVG_Clock,
		MessageFull: SVG_MessageFull,
		Reply: SVG_Reply,
		More: SVG_More,
		Bookmark: SVG_Bookmark
	};

	function data() {
		return {
			svg: ''
		}
	}
	function oncreate() {
		this.set({svg: icons[this.get().name]});
	}
	function create_main_fragment$15(component, ctx) {
		var switch_instance_anchor;

		var switch_value = ctx.svg;

		function switch_props(ctx) {
			return {
				root: component.root
			};
		}

		if (switch_value) {
			var switch_instance = new switch_value(switch_props(ctx));
		}

		return {
			c: function create() {
				switch_instance_anchor = createComment();
				if (switch_instance) switch_instance._fragment.c();
			},

			m: function mount(target, anchor) {
				insertNode(switch_instance_anchor, target, anchor);

				if (switch_instance) {
					switch_instance._mount(target, anchor);
				}
			},

			p: function update(changed, ctx) {
				if (switch_value !== (switch_value = ctx.svg)) {
					if (switch_instance) switch_instance.destroy();

					if (switch_value) {
						switch_instance = new switch_value(switch_props(ctx));
						switch_instance._fragment.c();
						switch_instance._mount(switch_instance_anchor.parentNode, switch_instance_anchor);
					}
				}
			},

			u: function unmount() {
				detachNode(switch_instance_anchor);
				if (switch_instance) switch_instance._unmount();
			},

			d: function destroy$$1() {
				if (switch_instance) switch_instance.destroy(false);
			}
		};
	}

	function IconsSvg(options) {
		this._debugName = '<IconsSvg>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data(), options.data);
		if (!('svg' in this._state)) console.warn("<IconsSvg> was created without expected data property 'svg'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$15(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(IconsSvg.prototype, protoDev);

	IconsSvg.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/components/MenuItemIcon.html generated by Svelte v2.4.4 */



	function create_main_fragment$16(component, ctx) {
		var a, a_class_value, a_href_value;

		function select_block_type(ctx) {
			if (ctx.item.icon.svg) return create_if_block;
			if (ctx.item.icon.img) return create_if_block_1;
			return create_if_block_2;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				a = createElement("a");
				if_block.c();
				a.className = a_class_value = "menu-item " + (ctx.item.active ? 'active' : '') + " svelte-14homif";
				a.href = a_href_value = ctx.item.link;
			},

			m: function mount(target, anchor) {
				insertNode(a, target, anchor);
				if_block.m(a, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.u();
					if_block.d();
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(a, null);
				}

				if ((changed.item) && a_class_value !== (a_class_value = "menu-item " + (ctx.item.active ? 'active' : '') + " svelte-14homif")) {
					a.className = a_class_value;
				}

				if ((changed.item) && a_href_value !== (a_href_value = ctx.item.link)) {
					a.href = a_href_value;
				}
			},

			u: function unmount() {
				detachNode(a);
				if_block.u();
			},

			d: function destroy$$1() {
				if_block.d();
			}
		};
	}

	// (2:2) {#if item.icon.svg}
	function create_if_block(component, ctx) {
		var span;

		var iconssvg_initial_data = { name: ctx.item.icon.svg };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		return {
			c: function create() {
				span = createElement("span");
				iconssvg._fragment.c();
				span.className = "icon svelte-14homif";
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
				iconssvg._mount(span, null);
			},

			p: function update(changed, ctx) {
				var iconssvg_changes = {};
				if (changed.item) iconssvg_changes.name = ctx.item.icon.svg;
				iconssvg._set(iconssvg_changes);
			},

			u: function unmount() {
				detachNode(span);
			},

			d: function destroy$$1() {
				iconssvg.destroy(false);
			}
		};
	}

	// (6:25) 
	function create_if_block_1(component, ctx) {
		var span, img, img_src_value, img_alt_value;

		return {
			c: function create() {
				span = createElement("span");
				img = createElement("img");
				img.src = img_src_value = ctx.item.icon.img;
				img.alt = img_alt_value = ctx.item.icon.name;
				span.className = "icon svelte-14homif";
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
				appendNode(img, span);
			},

			p: function update(changed, ctx) {
				if ((changed.item) && img_src_value !== (img_src_value = ctx.item.icon.img)) {
					img.src = img_src_value;
				}

				if ((changed.item) && img_alt_value !== (img_alt_value = ctx.item.icon.name)) {
					img.alt = img_alt_value;
				}
			},

			u: function unmount() {
				detachNode(span);
			},

			d: noop
		};
	}

	// (10:2) {:else}
	function create_if_block_2(component, ctx) {
		var text_value = ctx.item.icon.name, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.item) && text_value !== (text_value = ctx.item.icon.name)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function MenuItemIcon(options) {
		this._debugName = '<MenuItemIcon>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('item' in this._state)) console.warn("<MenuItemIcon> was created without expected data property 'item'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$16(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(MenuItemIcon.prototype, protoDev);

	MenuItemIcon.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/components/SideNav.html generated by Svelte v2.4.4 */



	function create_main_fragment$17(component, ctx) {
		var nav, a, img, img_src_value, a_href_value, text_1, ul, text_2, div, await_block_1, await_block_type, await_token, promise, resolved;

		var each_value = ctx.menu;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_1;
			await_block_1 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_1.c();
				await_block_1.m(div, null);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { user: value };
					replace_await_block(token, create_then_block, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block) {
					replace_await_block(token, create_pending_block, ctx);
					return true;
				}
			} else {
				resolved = { user: promise };
				if (await_block_type !== create_then_block) {
					replace_await_block(token, create_then_block, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.user);

		return {
			c: function create() {
				nav = createElement("nav");
				a = createElement("a");
				img = createElement("img");
				text_1 = createText("\n\t");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_2 = createText("\n\t");
				div = createElement("div");

				await_block_1.c();
				img.className = "img svelte-bcg552";
				img.src = img_src_value = ctx.brand.img;
				img.alt = "Brand";
				a.className = "brand svelte-bcg552";
				a.href = a_href_value = ctx.brand.link;
				ul.className = "menu svelte-bcg552";
				div.className = "user-menu bottom svelte-bcg552";
				nav.className = "sidenav svelte-bcg552";
			},

			m: function mount(target, anchor) {
				insertNode(nav, target, anchor);
				appendNode(a, nav);
				appendNode(img, a);
				appendNode(text_1, nav);
				appendNode(ul, nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				appendNode(text_2, nav);
				appendNode(div, nav);

				await_block_1.m(div, null);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if ((changed.brand) && img_src_value !== (img_src_value = ctx.brand.img)) {
					img.src = img_src_value;
				}

				if ((changed.brand) && a_href_value !== (a_href_value = ctx.brand.link)) {
					a.href = a_href_value;
				}

				if (changed.menu) {
					each_value = ctx.menu;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = each_value.length;
				}

				if (('user' in changed) && promise !== (promise = ctx.user) && handle_promise(promise, ctx)) ; else {
					await_block_1.p(changed, assign(assign({}, ctx), resolved));
				}
			},

			u: function unmount() {
				detachNode(nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}

				await_block_1.u();
			},

			d: function destroy$$1() {
				destroyEach(each_blocks);

				await_token = null;
				await_block_1.d();
			}
		};
	}

	// (6:2) {#each menu as item}
	function create_each_block(component, ctx) {
		var li;

		var menuitemicon_initial_data = { item: ctx.item };
		var menuitemicon = new MenuItemIcon({
			root: component.root,
			data: menuitemicon_initial_data
		});

		return {
			c: function create() {
				li = createElement("li");
				menuitemicon._fragment.c();
				setStyle(li, "--color", ctx.item.icon.color);
			},

			m: function mount(target, anchor) {
				insertNode(li, target, anchor);
				menuitemicon._mount(li, null);
			},

			p: function update(changed, ctx) {
				var menuitemicon_changes = {};
				if (changed.menu) menuitemicon_changes.item = ctx.item;
				menuitemicon._set(menuitemicon_changes);

				if (changed.menu) {
					setStyle(li, "--color", ctx.item.icon.color);
				}
			},

			u: function unmount() {
				detachNode(li);
			},

			d: function destroy$$1() {
				menuitemicon.destroy(false);
			}
		};
	}

	// (13:15)    {:then user}
	function create_pending_block(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (14:2) {:then user}
	function create_then_block(component, ctx) {
		var a, img, img_src_value, a_href_value;

		return {
			c: function create() {
				a = createElement("a");
				img = createElement("img");
				img.className = "img svelte-bcg552";
				img.src = img_src_value = ctx.user.img;
				img.alt = "User Settings";
				a.href = a_href_value = ctx.user.link;
			},

			m: function mount(target, anchor) {
				insertNode(a, target, anchor);
				appendNode(img, a);
			},

			p: function update(changed, ctx) {
				if ((changed.user) && img_src_value !== (img_src_value = ctx.user.img)) {
					img.src = img_src_value;
				}

				if ((changed.user) && a_href_value !== (a_href_value = ctx.user.link)) {
					a.href = a_href_value;
				}
			},

			u: function unmount() {
				detachNode(a);
			},

			d: noop
		};
	}

	// (18:2) {:catch error}
	function create_catch_block(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	function get_each_context(ctx, list, i) {
		return assign(assign({}, ctx), {
			item: list[i],
			each_value: list,
			item_index: i
		});
	}

	function SideNav(options) {
		this._debugName = '<SideNav>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('brand' in this._state)) console.warn("<SideNav> was created without expected data property 'brand'");
		if (!('menu' in this._state)) console.warn("<SideNav> was created without expected data property 'menu'");
		if (!('user' in this._state)) console.warn("<SideNav> was created without expected data property 'user'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$17(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(SideNav.prototype, protoDev);

	SideNav.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/components/Banner.html generated by Svelte v2.4.4 */

	function data$1() {
		return {
			blur: false
		}
	}
	function create_main_fragment$18(component, ctx) {
		var div, div_1, img, img_src_value;

		return {
			c: function create() {
				div = createElement("div");
				div_1 = createElement("div");
				img = createElement("img");
				img.src = img_src_value = ctx.banner.img;
				img.alt = "banner";
				setStyle(img, "width", "" + ctx.banner.width + "%");
				setStyle(img, "top", "" + ctx.banner.top + "%");
				setStyle(img, "left", "" + ctx.banner.left + "%");
				img.className = "svelte-ya16h3";
				div_1.className = "banner svelte-ya16h3";
				setStyle(div_1, "filter", "blur(" + ctx.blur + "px)");
				div.className = "banner-wrapper svelte-ya16h3";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				appendNode(img, div_1);
			},

			p: function update(changed, ctx) {
				if ((changed.banner) && img_src_value !== (img_src_value = ctx.banner.img)) {
					img.src = img_src_value;
				}

				if (changed.banner) {
					setStyle(img, "width", "" + ctx.banner.width + "%");
					setStyle(img, "top", "" + ctx.banner.top + "%");
					setStyle(img, "left", "" + ctx.banner.left + "%");
				}

				if (changed.blur) {
					setStyle(div_1, "filter", "blur(" + ctx.blur + "px)");
				}
			},

			u: function unmount() {
				detachNode(div);
			},

			d: noop
		};
	}

	function Banner(options) {
		this._debugName = '<Banner>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$1(), options.data);
		if (!('blur' in this._state)) console.warn("<Banner> was created without expected data property 'blur'");
		if (!('banner' in this._state)) console.warn("<Banner> was created without expected data property 'banner'");

		this._fragment = create_main_fragment$18(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Banner.prototype, protoDev);

	Banner.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/components/Sidebar.html generated by Svelte v2.4.4 */

	function create_main_fragment$19(component, ctx) {
		var aside, slot_content_default = component._slotted.default;

		return {
			c: function create() {
				aside = createElement("aside");
				aside.className = "sidebar svelte-nzpcp1";
			},

			m: function mount(target, anchor) {
				insertNode(aside, target, anchor);

				if (slot_content_default) {
					appendNode(slot_content_default, aside);
				}
			},

			p: noop,

			u: function unmount() {
				detachNode(aside);

				if (slot_content_default) {
					reinsertChildren(aside, slot_content_default);
				}
			},

			d: noop
		};
	}

	function Sidebar(options) {
		this._debugName = '<Sidebar>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._slotted = options.slots || {};

		this.slots = {};

		this._fragment = create_main_fragment$19(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Sidebar.prototype, protoDev);

	Sidebar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/components/Tiles.html generated by Svelte v2.4.4 */

	function create_main_fragment$20(component, ctx) {
		var div;

		var each_value = ctx.tiles;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
		}

		return {
			c: function create() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div.className = "tiles svelte-1p0pifj";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.tiles) {
					each_value = ctx.tiles;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = each_value.length;
				}
			},

			u: function unmount() {
				detachNode(div);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}
			},

			d: function destroy$$1() {
				destroyEach(each_blocks);
			}
		};
	}

	// (2:2) {#each tiles as tile, i}
	function create_each_block$1(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.i < 9) && create_if_block$1(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insertNode(if_block_anchor, target, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.i < 9) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$1(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.u();
					if_block.d();
					if_block = null;
				}
			},

			u: function unmount() {
				if (if_block) if_block.u();
				detachNode(if_block_anchor);
			},

			d: function destroy$$1() {
				if (if_block) if_block.d();
			}
		};
	}

	// (3:4) {#if i < 9}
	function create_if_block$1(component, ctx) {
		var a, a_href_value, a_title_value;

		return {
			c: function create() {
				a = createElement("a");
				a.className = "tile svelte-1p0pifj";
				a.href = a_href_value = ctx.tile.link;
				a.title = a_title_value = ctx.tile.title;
				setStyle(a, "background-image", "url('" + ctx.tile.img + "')");
			},

			m: function mount(target, anchor) {
				insertNode(a, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.tiles) && a_href_value !== (a_href_value = ctx.tile.link)) {
					a.href = a_href_value;
				}

				if ((changed.tiles) && a_title_value !== (a_title_value = ctx.tile.title)) {
					a.title = a_title_value;
				}

				if (changed.tiles) {
					setStyle(a, "background-image", "url('" + ctx.tile.img + "')");
				}
			},

			u: function unmount() {
				detachNode(a);
			},

			d: noop
		};
	}

	function get_each_context$1(ctx, list, i) {
		return assign(assign({}, ctx), {
			tile: list[i],
			each_value: list,
			i: i
		});
	}

	function Tiles(options) {
		this._debugName = '<Tiles>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('tiles' in this._state)) console.warn("<Tiles> was created without expected data property 'tiles'");

		this._fragment = create_main_fragment$20(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Tiles.prototype, protoDev);

	Tiles.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/profile/SidebarProfile.html generated by Svelte v2.4.4 */



	function create_main_fragment$21(component, ctx) {
		var slot_content_default = component._slotted.default, slot_content_default_before, slot_content_default_after, text, main, h2, span, text_1, text_2, text_3, h2_1, span_1, text_4, a, text_7, div;

		function select_block_type(ctx) {
			if (ctx.fixed) return create_if_block$2;
			return create_if_block_1$1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		var iconssvg_initial_data = { name: "Camera" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		var tiles_initial_data = { tiles: ctx.profile.projects };
		var tiles = new Tiles({
			root: component.root,
			data: tiles_initial_data
		});

		var iconssvg_1_initial_data = { name: "Star" };
		var iconssvg_1 = new IconsSvg({
			root: component.root,
			data: iconssvg_1_initial_data
		});

		return {
			c: function create() {
				if (!slot_content_default) {
					if_block.c();
					text = createText("\n\n\t");
					main = createElement("main");
					h2 = createElement("h2");
					span = createElement("span");
					iconssvg._fragment.c();
					text_1 = createText(" Projects");
					text_2 = createText("\n\t\t");
					tiles._fragment.c();
					text_3 = createText("\n\n\t\t");
					h2_1 = createElement("h2");
					span_1 = createElement("span");
					iconssvg_1._fragment.c();
					text_4 = createText(" Boosts\n\t\t\t");
					a = createElement("a");
					a.textContent = "More";
					text_7 = createText("\n\t\t");
					div = createElement("div");
				}
				if (!slot_content_default) {
					span.className = "icon svelte-p80zdo";
					h2.className = "title svelte-p80zdo";
					span_1.className = "icon icon-star svelte-p80zdo";
					a.className = "right link";
					a.href = "/";
					h2_1.className = "title svelte-p80zdo";
					div.className = "rows";
					main.className = "svelte-p80zdo";
				}
			},

			m: function mount(target, anchor) {
				if (!slot_content_default) {
					if_block.m(target, anchor);
					insertNode(text, target, anchor);
					insertNode(main, target, anchor);
					appendNode(h2, main);
					appendNode(span, h2);
					iconssvg._mount(span, null);
					appendNode(text_1, h2);
					appendNode(text_2, main);
					tiles._mount(main, null);
					appendNode(text_3, main);
					appendNode(h2_1, main);
					appendNode(span_1, h2_1);
					iconssvg_1._mount(span_1, null);
					appendNode(text_4, h2_1);
					appendNode(a, h2_1);
					appendNode(text_7, main);
					appendNode(div, main);
				}

				else {
					insertNode(slot_content_default_before || (slot_content_default_before = createComment()), target, anchor);
					insertNode(slot_content_default, target, anchor);
					insertNode(slot_content_default_after || (slot_content_default_after = createComment()), target, anchor);
				}
			},

			p: function update(changed, ctx) {
				if (!slot_content_default) {

						if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block.u();
						if_block.d();
						if_block = current_block_type(component, ctx);
						if_block.c();
						if_block.m(text.parentNode, text);
					}

						var tiles_changes = {};
					if (changed.profile) tiles_changes.tiles = ctx.profile.projects;
					tiles._set(tiles_changes);

				}
			},

			u: function unmount() {
				if (!slot_content_default) {
					if_block.u();
					detachNode(text);
					detachNode(main);
				}

				else {
					reinsertBetween(slot_content_default_before, slot_content_default_after, slot_content_default);
					detachNode(slot_content_default_before);
					detachNode(slot_content_default_after);
				}
			},

			d: function destroy$$1() {
				if (!slot_content_default) {
					if_block.d();
					iconssvg.destroy(false);
					tiles.destroy(false);
					iconssvg_1.destroy(false);
				}
			}
		};
	}

	// (5:17)       <div class="profile-img img"></div>     {:then user}
	function create_pending_block$1(component, ctx) {
		var div;

		return {
			c: function create() {
				div = createElement("div");
				div.className = "profile-img img svelte-p80zdo";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(div);
			},

			d: noop
		};
	}

	// (7:4) {:then user}
	function create_then_block$1(component, ctx) {
		var img, img_src_value, img_alt_value;

		return {
			c: function create() {
				img = createElement("img");
				img.className = "profile-img img svelte-p80zdo";
				img.src = img_src_value = ctx.user.img;
				img.alt = img_alt_value = ctx.user.name;
			},

			m: function mount(target, anchor) {
				insertNode(img, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.user) && img_src_value !== (img_src_value = ctx.user.img)) {
					img.src = img_src_value;
				}

				if ((changed.user) && img_alt_value !== (img_alt_value = ctx.user.name)) {
					img.alt = img_alt_value;
				}
			},

			u: function unmount() {
				detachNode(img);
			},

			d: noop
		};
	}

	// (9:4) {:catch error}
	function create_catch_block$1(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (27:16)      <div class="profile-img img"></div>    {:then user}
	function create_pending_block_1(component, ctx) {
		var div;

		return {
			c: function create() {
				div = createElement("div");
				div.className = "profile-img img svelte-p80zdo";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(div);
			},

			d: noop
		};
	}

	// (29:3) {:then user}
	function create_then_block_1(component, ctx) {
		var img, img_class_value, img_src_value, img_alt_value;

		return {
			c: function create() {
				img = createElement("img");
				img.className = img_class_value = "profile-img img animate " + (ctx.animate ? 'scale' : '') + " svelte-p80zdo";
				img.src = img_src_value = ctx.user.img;
				img.alt = img_alt_value = ctx.user.name;
			},

			m: function mount(target, anchor) {
				insertNode(img, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.animate) && img_class_value !== (img_class_value = "profile-img img animate " + (ctx.animate ? 'scale' : '') + " svelte-p80zdo")) {
					img.className = img_class_value;
				}

				if ((changed.user) && img_src_value !== (img_src_value = ctx.user.img)) {
					img.src = img_src_value;
				}

				if ((changed.user) && img_alt_value !== (img_alt_value = ctx.user.name)) {
					img.alt = img_alt_value;
				}
			},

			u: function unmount() {
				detachNode(img);
			},

			d: noop
		};
	}

	// (31:3) {:catch error}
	function create_catch_block_1(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (2:1) {#if fixed}
	function create_if_block$2(component, ctx) {
		var div, header, await_block_1, await_block_type, await_token, promise, resolved, text, button, span, text_2, div_1, div_2, button_1, text_6, p, text_7_value = ctx.profile.details.followers, text_7, div_class_value;

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_1;
			await_block_1 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_1.c();
				await_block_1.m(header, text);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { user: value };
					replace_await_block(token, create_then_block$1, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block$1, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block$1) {
					replace_await_block(token, create_pending_block$1, ctx);
					return true;
				}
			} else {
				resolved = { user: promise };
				if (await_block_type !== create_then_block$1) {
					replace_await_block(token, create_then_block$1, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.user);

		var iconssvg_initial_data = { name: "UserAdd" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		return {
			c: function create() {
				div = createElement("div");
				header = createElement("header");

				await_block_1.c();

				text = createText("\n\t\t\t\t");
				button = createElement("button");
				span = createElement("span");
				iconssvg._fragment.c();
				text_2 = createText("\n\t\t\t\t");
				div_1 = createElement("div");
				div_2 = createElement("div");
				button_1 = createElement("button");
				button_1.innerHTML = "<h2 class=\"title svelte-p80zdo\">Follower</h2>\n\t\t\t\t\t\t\t<span class=\"dropdown-arrow\"></span>";
				text_6 = createText("\n\t\t\t\t\t\t");
				p = createElement("p");
				text_7 = createText(text_7_value);
				span.className = "icon svelte-p80zdo";
				button.className = "btn btn-icon svelte-p80zdo";
				button_1.className = "btn-dropdown svelte-p80zdo";
				p.className = "highlight info svelte-p80zdo";
				div_2.className = "col svelte-p80zdo";
				div_1.className = "info-row lg row svelte-p80zdo";
				header.className = "row vCentered svelte-p80zdo";
				div.className = div_class_value = "header-wrapper sticky " + (ctx.fixed ? 'fixed' : '') + " svelte-p80zdo";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(header, div);

				await_block_1.m(header, null);

				appendNode(text, header);
				appendNode(button, header);
				appendNode(span, button);
				iconssvg._mount(span, null);
				appendNode(text_2, header);
				appendNode(div_1, header);
				appendNode(div_2, div_1);
				appendNode(button_1, div_2);
				appendNode(text_6, div_2);
				appendNode(p, div_2);
				appendNode(text_7, p);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (('user' in changed) && promise !== (promise = ctx.user) && handle_promise(promise, ctx)) ; else {
					await_block_1.p(changed, assign(assign({}, ctx), resolved));
				}

				if ((changed.profile) && text_7_value !== (text_7_value = ctx.profile.details.followers)) {
					text_7.data = text_7_value;
				}

				if ((changed.fixed) && div_class_value !== (div_class_value = "header-wrapper sticky " + (ctx.fixed ? 'fixed' : '') + " svelte-p80zdo")) {
					div.className = div_class_value;
				}
			},

			u: function unmount() {
				detachNode(div);

				await_block_1.u();
			},

			d: function destroy$$1() {
				await_token = null;
				await_block_1.d();

				iconssvg.destroy(false);
			}
		};
	}

	// (25:1) {:else}
	function create_if_block_1$1(component, ctx) {
		var header, await_block_1, await_block_type, await_token, promise, resolved, text, div, button, span, text_1, text_2, div_1, div_2, h2, text_4, p, text_5_value = ctx.profile.details.followers, text_5, text_7, div_3, h2_1, text_9, p_1, text_10_value = ctx.profile.details.following, text_10, text_13, div_4, h2_2, text_15, p_2, text_16_value = ctx.profile.details.perf, text_16, text_17, span_1, text_18, text_19_value = ctx.profile.details.reviews, text_19, text_20, div_class_value;

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_1;
			await_block_1 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_1.c();
				await_block_1.m(header, text);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { user: value };
					replace_await_block(token, create_then_block_1, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block_1, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block_1) {
					replace_await_block(token, create_pending_block_1, ctx);
					return true;
				}
			} else {
				resolved = { user: promise };
				if (await_block_type !== create_then_block_1) {
					replace_await_block(token, create_then_block_1, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.user);

		var iconssvg_initial_data = { name: "UserAdd" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		return {
			c: function create() {
				header = createElement("header");

				await_block_1.c();

				text = createText("\n\t\t\t");
				div = createElement("div");
				button = createElement("button");
				span = createElement("span");
				iconssvg._fragment.c();
				text_1 = createText("\n\t\t\t\t\tFollow");
				text_2 = createText("\n\t\t\t\t");
				div_1 = createElement("div");
				div_2 = createElement("div");
				h2 = createElement("h2");
				h2.textContent = "Follower";
				text_4 = createText("\n\t\t\t\t\t\t");
				p = createElement("p");
				text_5 = createText(text_5_value);
				text_7 = createText("\n\t\t\t\t\t");
				div_3 = createElement("div");
				h2_1 = createElement("h2");
				h2_1.textContent = "Folowing";
				text_9 = createText("\n\t\t\t\t\t\t");
				p_1 = createElement("p");
				text_10 = createText(text_10_value);
				text_13 = createText("\n\t\t\t\t");
				div_4 = createElement("div");
				h2_2 = createElement("h2");
				h2_2.textContent = "Performance";
				text_15 = createText("\n\t\t\t\t\t");
				p_2 = createElement("p");
				text_16 = createText(text_16_value);
				text_17 = createText(" ");
				span_1 = createElement("span");
				text_18 = createText("and ");
				text_19 = createText(text_19_value);
				text_20 = createText(" reviews");
				span.className = "icon svelte-p80zdo";
				button.className = "btn btn-lg svelte-p80zdo";
				h2.className = "title svelte-p80zdo";
				p.className = "highlight info svelte-p80zdo";
				div_2.className = "col svelte-p80zdo";
				h2_1.className = "title svelte-p80zdo";
				p_1.className = "highlight info svelte-p80zdo";
				div_3.className = "col svelte-p80zdo";
				div_1.className = "info-row lg row svelte-p80zdo";
				h2_2.className = "title svelte-p80zdo";
				span_1.className = "note svelte-p80zdo";
				p_2.className = "highlight info svelte-p80zdo";
				div_4.className = "col info-row row-left svelte-p80zdo";
				div.className = div_class_value = "animate " + (ctx.animate ? 'fade' : '') + " svelte-p80zdo";
				header.className = "svelte-p80zdo";
			},

			m: function mount(target, anchor) {
				insertNode(header, target, anchor);

				await_block_1.m(header, null);

				appendNode(text, header);
				appendNode(div, header);
				appendNode(button, div);
				appendNode(span, button);
				iconssvg._mount(span, null);
				appendNode(text_1, button);
				appendNode(text_2, div);
				appendNode(div_1, div);
				appendNode(div_2, div_1);
				appendNode(h2, div_2);
				appendNode(text_4, div_2);
				appendNode(p, div_2);
				appendNode(text_5, p);
				appendNode(text_7, div_1);
				appendNode(div_3, div_1);
				appendNode(h2_1, div_3);
				appendNode(text_9, div_3);
				appendNode(p_1, div_3);
				appendNode(text_10, p_1);
				appendNode(text_13, div);
				appendNode(div_4, div);
				appendNode(h2_2, div_4);
				appendNode(text_15, div_4);
				appendNode(p_2, div_4);
				appendNode(text_16, p_2);
				appendNode(text_17, p_2);
				appendNode(span_1, p_2);
				appendNode(text_18, span_1);
				appendNode(text_19, span_1);
				appendNode(text_20, span_1);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (('user' in changed) && promise !== (promise = ctx.user) && handle_promise(promise, ctx)) ; else {
					await_block_1.p(changed, assign(assign({}, ctx), resolved));
				}

				if ((changed.profile) && text_5_value !== (text_5_value = ctx.profile.details.followers)) {
					text_5.data = text_5_value;
				}

				if ((changed.profile) && text_10_value !== (text_10_value = ctx.profile.details.following)) {
					text_10.data = text_10_value;
				}

				if ((changed.profile) && text_16_value !== (text_16_value = ctx.profile.details.perf)) {
					text_16.data = text_16_value;
				}

				if ((changed.profile) && text_19_value !== (text_19_value = ctx.profile.details.reviews)) {
					text_19.data = text_19_value;
				}

				if ((changed.animate) && div_class_value !== (div_class_value = "animate " + (ctx.animate ? 'fade' : '') + " svelte-p80zdo")) {
					div.className = div_class_value;
				}
			},

			u: function unmount() {
				detachNode(header);

				await_block_1.u();
			},

			d: function destroy$$1() {
				await_token = null;
				await_block_1.d();

				iconssvg.destroy(false);
			}
		};
	}

	function SidebarProfile(options) {
		this._debugName = '<SidebarProfile>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('fixed' in this._state)) console.warn("<SidebarProfile> was created without expected data property 'fixed'");
		if (!('user' in this._state)) console.warn("<SidebarProfile> was created without expected data property 'user'");
		if (!('profile' in this._state)) console.warn("<SidebarProfile> was created without expected data property 'profile'");
		if (!('animate' in this._state)) console.warn("<SidebarProfile> was created without expected data property 'animate'");

		this._slotted = options.slots || {};

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this.slots = {};

		this._fragment = create_main_fragment$21(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(SidebarProfile.prototype, protoDev);

	SidebarProfile.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/components/Stars.html generated by Svelte v2.4.4 */

	function setStars(node) {
		var rating = this.get().rating,
				addedStars = 0;
		for (var i=1; i<=rating; i++) {
			addStar('fullstar');
			addedStars += 1;
		}
		if (rating !== addedStars && rating > addedStars && rating - addedStars >= .5) {
			addStar('halfstar');
			i += 1;
		}
		for (i; i<6; i++) {
			addStar();
		}
		function addStar(klass) {
			var star = document.createElement('span');
			if (klass) star.classList.add(klass);
			node.append(star);
		}
	}
	function create_main_fragment$22(component, ctx) {
		var span, setStars_action;

		return {
			c: function create() {
				span = createElement("span");
				span.className = "icon-stars svelte-2zmrik";
				setStars_action = setStars.call(component, span) || {};
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(span);
			},

			d: function destroy$$1() {
				if (typeof setStars_action.destroy === 'function') setStars_action.destroy.call(component);
			}
		};
	}

	function Stars(options) {
		this._debugName = '<Stars>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$22(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Stars.prototype, protoDev);

	Stars.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/profile/HeaderProfile.html generated by Svelte v2.4.4 */



	function create_main_fragment$23(component, ctx) {
		var header, div, await_block_1, await_block_type, await_token, promise, resolved, text_1, div_1, button, span, text_2, button_1, header_class_value;

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_1;
			await_block_1 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_1.c();
				await_block_1.m(div, null);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { user: value };
					replace_await_block(token, create_then_block$2, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block$2, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block$2) {
					replace_await_block(token, create_pending_block$2, ctx);
					return true;
				}
			} else {
				resolved = { user: promise };
				if (await_block_type !== create_then_block$2) {
					replace_await_block(token, create_then_block$2, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.user);

		var iconssvg_initial_data = { name: "Message" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		return {
			c: function create() {
				header = createElement("header");
				div = createElement("div");

				await_block_1.c();

				text_1 = createText("\n\t");
				div_1 = createElement("div");
				button = createElement("button");
				span = createElement("span");
				iconssvg._fragment.c();
				text_2 = createText("\n\t\t");
				button_1 = createElement("button");
				button_1.textContent = "Request";
				span.className = "icon svelte-1c8md90";
				button.className = "btn btn-icon svelte-1c8md90";
				button_1.className = "btn btn-primary";
				div_1.className = "row";
				header.className = header_class_value = "row vCentered sticky " + (ctx.fixed? 'fixed' : '') + " svelte-1c8md90";
			},

			m: function mount(target, anchor) {
				insertNode(header, target, anchor);
				appendNode(div, header);

				await_block_1.m(div, null);

				appendNode(text_1, header);
				appendNode(div_1, header);
				appendNode(button, div_1);
				appendNode(span, button);
				iconssvg._mount(span, null);
				appendNode(text_2, div_1);
				appendNode(button_1, div_1);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (('user' in changed) && promise !== (promise = ctx.user) && handle_promise(promise, ctx)) ; else {
					await_block_1.p(changed, assign(assign({}, ctx), resolved));
				}

				if ((changed.fixed) && header_class_value !== (header_class_value = "row vCentered sticky " + (ctx.fixed? 'fixed' : '') + " svelte-1c8md90")) {
					header.className = header_class_value;
				}
			},

			u: function unmount() {
				detachNode(header);

				await_block_1.u();
			},

			d: function destroy$$1() {
				await_token = null;
				await_block_1.d();

				iconssvg.destroy(false);
			}
		};
	}

	// (3:15)    {:then user}
	function create_pending_block$2(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (4:2) {:then user}
	function create_then_block$2(component, ctx) {
		var h1, text_value = ctx.user.name, text, text_1, p, text_2_value = ctx.user.title, text_2, text_3;

		var stars_initial_data = { rating: ctx.profile.details.rating };
		var stars = new Stars({
			root: component.root,
			data: stars_initial_data
		});

		return {
			c: function create() {
				h1 = createElement("h1");
				text = createText(text_value);
				text_1 = createText("\n\t\t\t");
				p = createElement("p");
				text_2 = createText(text_2_value);
				text_3 = createText(" ");
				stars._fragment.c();
				h1.className = "svelte-1c8md90";
				p.className = "svelte-1c8md90";
			},

			m: function mount(target, anchor) {
				insertNode(h1, target, anchor);
				appendNode(text, h1);
				insertNode(text_1, target, anchor);
				insertNode(p, target, anchor);
				appendNode(text_2, p);
				appendNode(text_3, p);
				stars._mount(p, null);
			},

			p: function update(changed, ctx) {
				if ((changed.user) && text_value !== (text_value = ctx.user.name)) {
					text.data = text_value;
				}

				if ((changed.user) && text_2_value !== (text_2_value = ctx.user.title)) {
					text_2.data = text_2_value;
				}

				var stars_changes = {};
				if (changed.profile) stars_changes.rating = ctx.profile.details.rating;
				stars._set(stars_changes);
			},

			u: function unmount() {
				detachNode(h1);
				detachNode(text_1);
				detachNode(p);
			},

			d: function destroy$$1() {
				stars.destroy(false);
			}
		};
	}

	// (7:2) {:catch error}
	function create_catch_block$2(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	function HeaderProfile(options) {
		this._debugName = '<HeaderProfile>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('fixed' in this._state)) console.warn("<HeaderProfile> was created without expected data property 'fixed'");
		if (!('user' in this._state)) console.warn("<HeaderProfile> was created without expected data property 'user'");
		if (!('profile' in this._state)) console.warn("<HeaderProfile> was created without expected data property 'profile'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$23(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(HeaderProfile.prototype, protoDev);

	HeaderProfile.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/profile/content/ProfileInfo.html generated by Svelte v2.4.4 */

	function create_main_fragment$24(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Profile info");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function ProfileInfo(options) {
		this._debugName = '<ProfileInfo>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$24(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProfileInfo.prototype, protoDev);

	ProfileInfo.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	const USERS = [
	  {
	    id: '01',
	    img: 'https://pbs.twimg.com/profile_images/974736784906248192/gPZwCbdS.jpg'
	  },
	  {
	    id: '02',
	    img: 'https://d3iw72m71ie81c.cloudfront.net/male-3.jpg',
	    name: 'Mario Mendez',
	    title: 'Senior Architect',
	    link: ''
	  },
	  {
	    id: '03',
	    img: 'https://images.pexels.com/photos/274595/pexels-photo-274595.jpeg?h=350&auto=compress&cs=tinysrgb',
	    name: 'Jessica Simmons',
	    link: '',
	  },
	  {
	    id: '04',
	    img: 'https://tinyfac.es/data/avatars/087B1143-3859-4476-A85C-C120BBA0778F-500w.jpeg',
	    name: '',
	    link: '',
	  },
	  {
	    id: '05',
	    img: 'https://d3iw72m71ie81c.cloudfront.net/female-57.jpg',
	    name: '',
	    link: '',
	  },
	  {
	    id: '06',
	    img: '',
	    name: 'Frank Goodman',
	    title: 'Urban Planner',
	    link: '',
	    tags: ['architect']
	  },
	  {
	    id: '07',
	    img: '',
	    name: 'Luiza L. Alves',
	    title: 'Landscape Architect',
	    link: '',
	    tags: ['architect']
	  },
	  {
	    id: '08',
	    img: '',
	    name: 'Cesar Arojo',
	    title: 'Senior Architect',
	    link: '',
	    tags: ['architect']
	  },
	  {
	    id: '09',
	    img: '',
	    name: 'Robin Drummont',
	    title: 'Architect',
	    link: '',
	    tags: ['architect']
	  },
	  {
	    id: '10',
	    img: '',
	    name: 'Myles Steven',
	    title: 'Junior Architect',
	    link: '',
	    tags: ['architect']
	  },
	  {
	    id: '11',
	    img: '',
	    name: 'Joel Sanders',
	    title: 'Architect',
	    location: 'New York',
	    link: '',
	    tags: ['architect']
	  },
	];

	var api = {
	  getUsers() {
	    //python -m SimpleHTTPServer
	    //
	    // return fetch('http://localhost:8080/users.json').then(res=>{
	      // return res.json();
	    // });
	    return new Promise((resolve) => {
	      resolve(USERS);
	    });
	  },
	  findUser(id){
	    return new Promise((resolve) => {
	      setTimeout(() => {
	        resolve(USERS.find(x => x.id === id));
	      }, 1500);
	      // resolve(USERS.find(x => x.id === id));
	    });
	  },
	  findUsers(ids) {
	    var users = [];
	    ids.forEach(id => {
	      users.push(USERS.find(x => x.id === id));
	    });
	    return new Promise((resolve) => {
	      // resolve(users);
	      setTimeout(() => {
	        resolve(users);
	      }, 1500);
	    });
	  }
	};

	/* src/components/Avatar.html generated by Svelte v2.4.4 */

	function oncreate$1() {
	  if (this.get().isReview) {
	    this.set({user: api.findUser(this.get().user)});
	  }
	}
	function create_main_fragment$25(component, ctx) {
		var await_block_anchor, await_block_1, await_block_type, await_token, promise, resolved;

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_1;
			await_block_1 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_1.c();
				await_block_1.m(await_block_anchor.parentNode, await_block_anchor);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { user: value };
					replace_await_block(token, create_then_block$3, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block$3, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block$3) {
					replace_await_block(token, create_pending_block$3, ctx);
					return true;
				}
			} else {
				resolved = { user: promise };
				if (await_block_type !== create_then_block$3) {
					replace_await_block(token, create_then_block$3, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.user);

		return {
			c: function create() {
				await_block_anchor = createComment();

				await_block_1.c();
			},

			m: function mount(target, anchor) {
				insertNode(await_block_anchor, target, anchor);

				await_block_1.m(target, anchor);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (('user' in changed) && promise !== (promise = ctx.user) && handle_promise(promise, ctx)) ; else {
					await_block_1.p(changed, assign(assign({}, ctx), resolved));
				}
			},

			u: function unmount() {
				detachNode(await_block_anchor);

				await_block_1.u();
			},

			d: function destroy$$1() {
				await_token = null;
				await_block_1.d();
			}
		};
	}

	// (1:13)    <div class="avatar"></div> {:then user}
	function create_pending_block$3(component, ctx) {
		var div;

		return {
			c: function create() {
				div = createElement("div");
				div.className = "avatar svelte-7kaina";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(div);
			},

			d: noop
		};
	}

	// (3:0) {:then user}
	function create_then_block$3(component, ctx) {
		var a, img, img_src_value, img_alt_value, a_href_value;

		return {
			c: function create() {
				a = createElement("a");
				img = createElement("img");
				img.src = img_src_value = ctx.user.img;
				img.alt = img_alt_value = ctx.user.name;
				img.className = "svelte-7kaina";
				a.className = "avatar svelte-7kaina";
				a.href = a_href_value = ctx.user.link;
			},

			m: function mount(target, anchor) {
				insertNode(a, target, anchor);
				appendNode(img, a);
			},

			p: function update(changed, ctx) {
				if ((changed.user) && img_src_value !== (img_src_value = ctx.user.img)) {
					img.src = img_src_value;
				}

				if ((changed.user) && img_alt_value !== (img_alt_value = ctx.user.name)) {
					img.alt = img_alt_value;
				}

				if ((changed.user) && a_href_value !== (a_href_value = ctx.user.link)) {
					a.href = a_href_value;
				}
			},

			u: function unmount() {
				detachNode(a);
			},

			d: noop
		};
	}

	// (7:0) {:catch error}
	function create_catch_block$3(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	function Avatar(options) {
		this._debugName = '<Avatar>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('user' in this._state)) console.warn("<Avatar> was created without expected data property 'user'");

		if (!options.root) {
			this._oncreate = [];
		}

		this._fragment = create_main_fragment$25(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$1.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			callAll(this._oncreate);
		}
	}

	assign(Avatar.prototype, protoDev);

	Avatar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/posts/PostTitle.html generated by Svelte v2.4.4 */

	function postPeriod({date}) {
					var today = new Date(),
	      postDate = new Date(date),
	      period = 0;
	  if (today.getFullYear() !== postDate.getFullYear()) {
	    period = today.getFullYear() - postDate.getFullYear();
	    period = period > 1 ? period + ' years' : period + ' year';
	  } else if (today.getMonth() !== postDate.getMonth()) {
	    period = today.getMonth() - postDate.getMonth();
	    period = period > 1 ? period + ' months' : period + ' month';
	  } else if (today.getDate() !== postDate.getDate()) {
	    period = today.getDate() - postDate.getDate();
	    period = period > 1 ? period + ' days' : period + ' day';
	  } else if (today.getHours() !== postDate.getHours()) {
	    period = today.getHours() - postDate.getHours();
	    period = period > 1 ? period + ' hours' : period + ' hour';
	  } else if (today.getMinutes() !== postDate.getMinutes()) {
	    period = today.getMinutes() - postDate.getMinutes();
	    period = period > 1 ? period + ' minutes' : period + ' minute';
	  } else if (today.getSeconds() !== postDate.getSeconds()) {
	    period = today.getSeconds() - postDate.getSeconds();
	    period = period > 1 ? period + ' seconds' : period + ' second';
	  }
	  return period;
				}

	function data$2() {
	  return {
	    isSponsored: false,
	    bookmarked: false
	  }
	}
	var methods = {
	  addBookmark() {
	    this.set({bookmarked: !this.get().bookmarked});
	    // do bookmarking
	  }
	};

	function oncreate$2() {
	  if (this.get().isReview) {
	    this.set({user: api.findUser(this.get().user)});
	  }
	}
	function create_main_fragment$26(component, ctx) {
		var div, p, await_block_1, await_block_type, await_token, promise, resolved, text, span, span_1, text_1, text_2, text_4;

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_1;
			await_block_1 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_1.c();
				await_block_1.m(p, text);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { user: value };
					replace_await_block(token, create_then_block$4, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block$4, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block$4) {
					replace_await_block(token, create_pending_block$4, ctx);
					return true;
				}
			} else {
				resolved = { user: promise };
				if (await_block_type !== create_then_block$4) {
					replace_await_block(token, create_then_block$4, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.user);

		var iconssvg_initial_data = { name: "Clock" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		var if_block = (ctx.isSponsored) && create_if_block$3(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				p = createElement("p");

				await_block_1.c();

				text = createText("\n    ");
				span = createElement("span");
				span_1 = createElement("span");
				iconssvg._fragment.c();
				text_1 = createText(" ");
				text_2 = createText(ctx.postPeriod);
				text_4 = createText("\n  ");
				if (if_block) if_block.c();
				span_1.className = "icon note svelte-1bde89r";
				span.className = "note svelte-1bde89r";
				div.className = "post-title row svelte-1bde89r";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(p, div);

				await_block_1.m(p, null);

				appendNode(text, p);
				appendNode(span, p);
				appendNode(span_1, span);
				iconssvg._mount(span_1, null);
				appendNode(text_1, span);
				appendNode(text_2, span);
				appendNode(text_4, div);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (('user' in changed) && promise !== (promise = ctx.user) && handle_promise(promise, ctx)) ; else {
					await_block_1.p(changed, assign(assign({}, ctx), resolved));
				}

				if (changed.postPeriod) {
					text_2.data = ctx.postPeriod;
				}

				if (ctx.isSponsored) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$3(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.u();
					if_block.d();
					if_block = null;
				}
			},

			u: function unmount() {
				detachNode(div);

				await_block_1.u();

				if (if_block) if_block.u();
			},

			d: function destroy$$1() {
				await_token = null;
				await_block_1.d();

				iconssvg.destroy(false);
				if (if_block) if_block.d();
			}
		};
	}

	// (3:17)      {:then user}
	function create_pending_block$4(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (4:4) {:then user}
	function create_then_block$4(component, ctx) {
		var span, text_value = ctx.user.name, text;

		return {
			c: function create() {
				span = createElement("span");
				text = createText(text_value);
				span.className = "user-name";
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
				appendNode(text, span);
			},

			p: function update(changed, ctx) {
				if ((changed.user) && text_value !== (text_value = ctx.user.name)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(span);
			},

			d: noop
		};
	}

	// (6:4) {:catch error}
	function create_catch_block$4(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (10:2) {#if isSponsored}
	function create_if_block$3(component, ctx) {
		var p, span, text_1, button, span_1, button_class_value;

		var iconssvg_initial_data = { name: "Bookmark" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		function click_handler(event) {
			component.addBookmark();
		}

		return {
			c: function create() {
				p = createElement("p");
				span = createElement("span");
				span.textContent = "Sponsored";
				text_1 = createText("\n      ");
				button = createElement("button");
				span_1 = createElement("span");
				iconssvg._fragment.c();
				span_1.className = "icon svelte-1bde89r";
				addListener(button, "click", click_handler);
				button.className = button_class_value = "link " + (ctx.bookmarked ? 'active' : '') + " svelte-1bde89r";
				p.className = "row row-bottom italic note svelte-1bde89r";
			},

			m: function mount(target, anchor) {
				insertNode(p, target, anchor);
				appendNode(span, p);
				appendNode(text_1, p);
				appendNode(button, p);
				appendNode(span_1, button);
				iconssvg._mount(span_1, null);
			},

			p: function update(changed, ctx) {
				if ((changed.bookmarked) && button_class_value !== (button_class_value = "link " + (ctx.bookmarked ? 'active' : '') + " svelte-1bde89r")) {
					button.className = button_class_value;
				}
			},

			u: function unmount() {
				detachNode(p);
			},

			d: function destroy$$1() {
				iconssvg.destroy(false);
				removeListener(button, "click", click_handler);
			}
		};
	}

	function PostTitle(options) {
		this._debugName = '<PostTitle>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$2(), options.data);
		this._recompute({ date: 1 }, this._state);
		if (!('date' in this._state)) console.warn("<PostTitle> was created without expected data property 'date'");
		if (!('user' in this._state)) console.warn("<PostTitle> was created without expected data property 'user'");

		if (!('isSponsored' in this._state)) console.warn("<PostTitle> was created without expected data property 'isSponsored'");
		if (!('bookmarked' in this._state)) console.warn("<PostTitle> was created without expected data property 'bookmarked'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$26(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$2.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(PostTitle.prototype, protoDev);
	assign(PostTitle.prototype, methods);

	PostTitle.prototype._checkReadOnly = function _checkReadOnly(newState) {
		if ('postPeriod' in newState && !this._updatingReadonlyProperty) throw new Error("<PostTitle>: Cannot set read-only property 'postPeriod'");
	};

	PostTitle.prototype._recompute = function _recompute(changed, state) {
		if (changed.date) {
			if (this._differs(state.postPeriod, (state.postPeriod = postPeriod(state)))) changed.postPeriod = true;
		}
	};

	/* src/posts/SponsoredPost.html generated by Svelte v2.4.4 */

	function data$3() {
	  return {
	    recommendationUsers: []
	  }
	}
	var methods$1 = {
	  setRecommendationUsers() {
	    var ids = this.get().post.recommendations.users;
	    ids = ids.splice(0,3);
	    // for (let i = 0; i < 3; i++) {
	      // api.findUsers(ids)
	      //   .then((recommendationUsers) => {
	      //     this.set({recommendationUsers});
	      //   });
	      var recommendationUsers = api.findUsers(ids);
	      this.set({recommendationUsers});
	    // }
	  }
	};

	function oncreate$3() {
	  if (this.get().post.recommendations.total > 0) this.setRecommendationUsers();
	}
	function create_main_fragment$27(component, ctx) {
		var div, div_1, text_1, div_2, div_3, div_4, raw_value = ctx.post.content.text, text_4, button;

		var if_block = (ctx.post.recommendations) && create_if_block$4(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				div_1 = createElement("div");
				if (if_block) if_block.c();
				text_1 = createText("\n  ");
				div_2 = createElement("div");
				div_3 = createElement("div");
				div_4 = createElement("div");
				text_4 = createText("\n    ");
				button = createElement("button");
				button.textContent = "Hire";
				div_1.className = "featured svelte-1v6ra7w";
				setStyle(div_1, "background-image", "url('" + ctx.post.content.img + "')");
				div_4.className = "ellipsis-content svelte-1v6ra7w";
				div_3.className = "content ellipsis svelte-1v6ra7w";
				button.className = "btn svelte-1v6ra7w";
				div_2.className = "row featured-text svelte-1v6ra7w";
				div.className = "box";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				if (if_block) if_block.m(div_1, null);
				appendNode(text_1, div);
				appendNode(div_2, div);
				appendNode(div_3, div_2);
				appendNode(div_4, div_3);
				div_4.innerHTML = raw_value;
				appendNode(text_4, div_2);
				appendNode(button, div_2);
			},

			p: function update(changed, ctx) {
				if (ctx.post.recommendations) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$4(component, ctx);
						if_block.c();
						if_block.m(div_1, null);
					}
				} else if (if_block) {
					if_block.u();
					if_block.d();
					if_block = null;
				}

				if (changed.post) {
					setStyle(div_1, "background-image", "url('" + ctx.post.content.img + "')");
				}

				if ((changed.post) && raw_value !== (raw_value = ctx.post.content.text)) {
					div_4.innerHTML = raw_value;
				}
			},

			u: function unmount() {
				div_4.innerHTML = '';

				detachNode(div);
				if (if_block) if_block.u();
			},

			d: function destroy$$1() {
				if (if_block) if_block.d();
			}
		};
	}

	// (5:36)            <p>loading</p>         {:then recommendationUsers}
	function create_pending_block$5(component, ctx) {
		var p;

		return {
			c: function create() {
				p = createElement("p");
				p.textContent = "loading";
				p.className = "svelte-1v6ra7w";
			},

			m: function mount(target, anchor) {
				insertNode(p, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(p);
			},

			d: noop
		};
	}

	// (8:10) {#each recommendationUsers as user}
	function create_each_block$2(component, ctx) {

		var avatar_initial_data = { user: ctx.user };
		var avatar = new Avatar({
			root: component.root,
			data: avatar_initial_data
		});

		return {
			c: function create() {
				avatar._fragment.c();
			},

			m: function mount(target, anchor) {
				avatar._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var avatar_changes = {};
				if (changed.recommendationUsers) avatar_changes.user = ctx.user;
				avatar._set(avatar_changes);
			},

			u: function unmount() {
				avatar._unmount();
			},

			d: function destroy$$1() {
				avatar.destroy(false);
			}
		};
	}

	// (7:8) {:then recommendationUsers}
	function create_then_block$5(component, ctx) {
		var each_anchor;

		var each_value = ctx.recommendationUsers;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(component, get_each_context$2(ctx, each_value, i));
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insertNode(each_anchor, target, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.recommendationUsers) {
					each_value = ctx.recommendationUsers;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$2(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = each_value.length;
				}
			},

			u: function unmount() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}

				detachNode(each_anchor);
			},

			d: function destroy$$1() {
				destroyEach(each_blocks);
			}
		};
	}

	// (11:8) {:catch error}
	function create_catch_block$5(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (14:10) {#if post.recommendations.rating}
	function create_if_block_1$2(component, ctx) {

		var stars_initial_data = { rating: ctx.post.recommendations.rating };
		var stars = new Stars({
			root: component.root,
			data: stars_initial_data
		});

		return {
			c: function create() {
				stars._fragment.c();
			},

			m: function mount(target, anchor) {
				stars._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var stars_changes = {};
				if (changed.post) stars_changes.rating = ctx.post.recommendations.rating;
				stars._set(stars_changes);
			},

			u: function unmount() {
				stars._unmount();
			},

			d: function destroy$$1() {
				stars.destroy(false);
			}
		};
	}

	// (17:10) {#if post.recommendations.total > 0}
	function create_if_block_2$1(component, ctx) {
		var p, text, text_1_value = ctx.post.recommendations.total, text_1, text_2;

		return {
			c: function create() {
				p = createElement("p");
				text = createText("(");
				text_1 = createText(text_1_value);
				text_2 = createText(") recommend this");
				p.className = "svelte-1v6ra7w";
			},

			m: function mount(target, anchor) {
				insertNode(p, target, anchor);
				appendNode(text, p);
				appendNode(text_1, p);
				appendNode(text_2, p);
			},

			p: function update(changed, ctx) {
				if ((changed.post) && text_1_value !== (text_1_value = ctx.post.recommendations.total)) {
					text_1.data = text_1_value;
				}
			},

			u: function unmount() {
				detachNode(p);
			},

			d: noop
		};
	}

	// (3:4) {#if post.recommendations}
	function create_if_block$4(component, ctx) {
		var div, await_block_1, await_block_type, await_token, promise, resolved, text, div_1, text_1;

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_1;
			await_block_1 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_1.c();
				await_block_1.m(div, text);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { recommendationUsers: value };
					replace_await_block(token, create_then_block$5, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block$5, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block$5) {
					replace_await_block(token, create_pending_block$5, ctx);
					return true;
				}
			} else {
				resolved = { recommendationUsers: promise };
				if (await_block_type !== create_then_block$5) {
					replace_await_block(token, create_then_block$5, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.recommendationUsers);

		var if_block = (ctx.post.recommendations.rating) && create_if_block_1$2(component, ctx);

		var if_block_1 = (ctx.post.recommendations.total > 0) && create_if_block_2$1(component, ctx);

		return {
			c: function create() {
				div = createElement("div");

				await_block_1.c();

				text = createText("\n        ");
				div_1 = createElement("div");
				if (if_block) if_block.c();
				text_1 = createText("\n          ");
				if (if_block_1) if_block_1.c();
				div_1.className = "details svelte-1v6ra7w";
				div.className = "row vCentered";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);

				await_block_1.m(div, null);

				appendNode(text, div);
				appendNode(div_1, div);
				if (if_block) if_block.m(div_1, null);
				appendNode(text_1, div_1);
				if (if_block_1) if_block_1.m(div_1, null);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (('recommendationUsers' in changed) && promise !== (promise = ctx.recommendationUsers) && handle_promise(promise, ctx)) ; else {
					await_block_1.p(changed, assign(assign({}, ctx), resolved));
				}

				if (ctx.post.recommendations.rating) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$2(component, ctx);
						if_block.c();
						if_block.m(div_1, text_1);
					}
				} else if (if_block) {
					if_block.u();
					if_block.d();
					if_block = null;
				}

				if (ctx.post.recommendations.total > 0) {
					if (if_block_1) {
						if_block_1.p(changed, ctx);
					} else {
						if_block_1 = create_if_block_2$1(component, ctx);
						if_block_1.c();
						if_block_1.m(div_1, null);
					}
				} else if (if_block_1) {
					if_block_1.u();
					if_block_1.d();
					if_block_1 = null;
				}
			},

			u: function unmount() {
				detachNode(div);

				await_block_1.u();

				if (if_block) if_block.u();
				if (if_block_1) if_block_1.u();
			},

			d: function destroy$$1() {
				await_token = null;
				await_block_1.d();

				if (if_block) if_block.d();
				if (if_block_1) if_block_1.d();
			}
		};
	}

	function get_each_context$2(ctx, list, i) {
		return assign(assign({}, ctx), {
			user: list[i],
			each_value: list,
			user_index: i
		});
	}

	function SponsoredPost(options) {
		this._debugName = '<SponsoredPost>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$3(), options.data);
		if (!('post' in this._state)) console.warn("<SponsoredPost> was created without expected data property 'post'");
		if (!('recommendationUsers' in this._state)) console.warn("<SponsoredPost> was created without expected data property 'recommendationUsers'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$27(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$3.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(SponsoredPost.prototype, protoDev);
	assign(SponsoredPost.prototype, methods$1);

	SponsoredPost.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/posts/ReviewPost.html generated by Svelte v2.4.4 */

	function data$4() {
	  return {
	    reviewUser: ''
	  }
	}
	function oncreate$4() {
	  this.set({reviewUser: api.findUser(this.get().post.review.user)});
	}
	function create_main_fragment$28(component, ctx) {
		var div, div_1, div_2, text, div_3, await_block_2, await_block_type, await_token, promise, resolved, text_1, text_4, div_4, span, text_5, text_6, span_1, text_10, div_5, p, raw_value = ctx.post.review.content.text, text_11, await_block_3, await_block_type_1, await_token_1, promise_1, resolved_1;

		var avatar_initial_data = { user: ctx.user };
		var avatar = new Avatar({
			root: component.root,
			data: avatar_initial_data
		});

		function replace_await_block(token, type, ctx) {
			if (token !== await_token) return;

			var old_block = await_block_2;
			await_block_2 = type && (await_block_type = type)(component, ctx);

			if (old_block) {
				old_block.u();
				old_block.d();
				await_block_2.c();
				await_block_2.m(div_3, text_1);

				component.root.set({});
			}
		}

		function handle_promise(promise) {
			var token = await_token = {};

			if (isPromise(promise)) {
				promise.then(function(value) {
					resolved = { user: value };
					replace_await_block(token, create_then_block$6, assign(assign({}, ctx), resolved));
				}, function (error) {
					resolved = { error: error };
					replace_await_block(token, create_catch_block$6, assign(assign({}, ctx), resolved));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type !== create_pending_block$6) {
					replace_await_block(token, create_pending_block$6, ctx);
					return true;
				}
			} else {
				resolved = { user: promise };
				if (await_block_type !== create_then_block$6) {
					replace_await_block(token, create_then_block$6, assign(assign({}, ctx), resolved));
					return true;
				}
			}
		}

		handle_promise(promise = ctx.user);

		var stars_initial_data = { rating: ctx.post.review.rating };
		var stars = new Stars({
			root: component.root,
			data: stars_initial_data
		});

		function replace_await_block_1(token_1, type, ctx) {
			if (token_1 !== await_token_1) return;

			var old_block_1 = await_block_3;
			await_block_3 = type && (await_block_type_1 = type)(component, ctx);

			if (old_block_1) {
				old_block_1.u();
				old_block_1.d();
				await_block_3.c();
				await_block_3.m(div_5, null);

				component.root.set({});
			}
		}

		function handle_promise_1(promise_1) {
			var token_1 = await_token_1 = {};

			if (isPromise(promise_1)) {
				promise_1.then(function(value_1) {
					resolved_1 = { reviewUser: value_1 };
					replace_await_block_1(token_1, create_then_block_1$1, assign(assign({}, ctx), resolved_1));
				}, function (error_1) {
					resolved_1 = { error: error_1 };
					replace_await_block_1(token_1, create_catch_block_1$1, assign(assign({}, ctx), resolved_1));
				});

				// if we previously had a then/catch block, destroy it
				if (await_block_type_1 !== create_pending_block_1$1) {
					replace_await_block_1(token_1, create_pending_block_1$1, ctx);
					return true;
				}
			} else {
				resolved_1 = { reviewUser: promise_1 };
				if (await_block_type_1 !== create_then_block_1$1) {
					replace_await_block_1(token_1, create_then_block_1$1, assign(assign({}, ctx), resolved_1));
					return true;
				}
			}
		}

		handle_promise_1(promise_1 = ctx.reviewUser);

		return {
			c: function create() {
				div = createElement("div");
				div_1 = createElement("div");
				div_2 = createElement("div");
				avatar._fragment.c();
				text = createText("\n        ");
				div_3 = createElement("div");

				await_block_2.c();

				text_1 = createText("\n          ");
				stars._fragment.c();
				text_4 = createText("\n      ");
				div_4 = createElement("div");
				span = createElement("span");
				text_5 = createText(ctx.rating);
				text_6 = createText("\n        ");
				span_1 = createElement("span");
				span_1.textContent = "RATED";
				text_10 = createText("\n    ");
				div_5 = createElement("div");
				p = createElement("p");
				text_11 = createText("\n      ");

				await_block_3.c();
				div_2.className = "user-info row vCentered svelte-k5nvbj";
				span.className = "note svelte-k5nvbj";
				div_4.className = "user-rating col svelte-k5nvbj";
				div_1.className = "row box-header svelte-k5nvbj";
				p.className = "quote svelte-k5nvbj";
				div_5.className = "box-content svelte-k5nvbj";
				div.className = "box-2";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				appendNode(div_2, div_1);
				avatar._mount(div_2, null);
				appendNode(text, div_2);
				appendNode(div_3, div_2);

				await_block_2.m(div_3, null);

				appendNode(text_1, div_3);
				stars._mount(div_3, null);
				appendNode(text_4, div_1);
				appendNode(div_4, div_1);
				appendNode(span, div_4);
				appendNode(text_5, span);
				appendNode(text_6, div_4);
				appendNode(span_1, div_4);
				appendNode(text_10, div);
				appendNode(div_5, div);
				appendNode(p, div_5);
				p.innerHTML = raw_value;
				appendNode(text_11, div_5);

				await_block_3.m(div_5, null);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				var avatar_changes = {};
				if (changed.user) avatar_changes.user = ctx.user;
				avatar._set(avatar_changes);

				if (('user' in changed) && promise !== (promise = ctx.user) && handle_promise(promise, ctx)) ; else {
					await_block_2.p(changed, assign(assign({}, ctx), resolved));
				}

				var stars_changes = {};
				if (changed.post) stars_changes.rating = ctx.post.review.rating;
				stars._set(stars_changes);

				if (changed.rating) {
					text_5.data = ctx.rating;
				}

				if ((changed.post) && raw_value !== (raw_value = ctx.post.review.content.text)) {
					p.innerHTML = raw_value;
				}

				if (('reviewUser' in changed) && promise_1 !== (promise_1 = ctx.reviewUser) && handle_promise_1(promise_1, ctx)) ; else {
					await_block_3.p(changed, assign(assign({}, ctx), resolved_1));
				}
			},

			u: function unmount() {
				p.innerHTML = '';

				detachNode(div);

				await_block_2.u();

				await_block_3.u();
			},

			d: function destroy$$1() {
				avatar.destroy(false);

				await_token = null;
				await_block_2.d();

				stars.destroy(false);

				await_token_1 = null;
				await_block_3.d();
			}
		};
	}

	// (6:23)            {:then user}
	function create_pending_block$6(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (7:10) {:then user}
	function create_then_block$6(component, ctx) {
		var p, text_value = ctx.user.name, text;

		return {
			c: function create() {
				p = createElement("p");
				text = createText(text_value);
				p.className = "user-name svelte-k5nvbj";
			},

			m: function mount(target, anchor) {
				insertNode(p, target, anchor);
				appendNode(text, p);
			},

			p: function update(changed, ctx) {
				if ((changed.user) && text_value !== (text_value = ctx.user.name)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(p);
			},

			d: noop
		};
	}

	// (9:10) {:catch error}
	function create_catch_block$6(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	// (21:25)          <p class="signature italic"><strong></strong></p>       {:then reviewUser}
	function create_pending_block_1$1(component, ctx) {
		var p;

		return {
			c: function create() {
				p = createElement("p");
				p.innerHTML = "<strong></strong>";
				p.className = "signature italic svelte-k5nvbj";
			},

			m: function mount(target, anchor) {
				insertNode(p, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(p);
			},

			d: noop
		};
	}

	// (23:6) {:then reviewUser}
	function create_then_block_1$1(component, ctx) {
		var p, strong, text_value = ctx.reviewUser.name, text;

		return {
			c: function create() {
				p = createElement("p");
				strong = createElement("strong");
				text = createText(text_value);
				p.className = "signature italic svelte-k5nvbj";
			},

			m: function mount(target, anchor) {
				insertNode(p, target, anchor);
				appendNode(strong, p);
				appendNode(text, strong);
			},

			p: function update(changed, ctx) {
				if ((changed.reviewUser) && text_value !== (text_value = ctx.reviewUser.name)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(p);
			},

			d: noop
		};
	}

	// (25:6) {:catch error}
	function create_catch_block_1$1(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	function ReviewPost(options) {
		this._debugName = '<ReviewPost>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$4(), options.data);
		if (!('user' in this._state)) console.warn("<ReviewPost> was created without expected data property 'user'");
		if (!('post' in this._state)) console.warn("<ReviewPost> was created without expected data property 'post'");
		if (!('rating' in this._state)) console.warn("<ReviewPost> was created without expected data property 'rating'");
		if (!('reviewUser' in this._state)) console.warn("<ReviewPost> was created without expected data property 'reviewUser'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$28(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$4.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(ReviewPost.prototype, protoDev);

	ReviewPost.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/posts/Post.html generated by Svelte v2.4.4 */

	function create_main_fragment$29(component, ctx) {
		var div, raw_value = ctx.post.content.text;

		return {
			c: function create() {
				div = createElement("div");
				div.className = "post-text svelte-6k3w7e";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				div.innerHTML = raw_value;
			},

			p: function update(changed, ctx) {
				if ((changed.post) && raw_value !== (raw_value = ctx.post.content.text)) {
					div.innerHTML = raw_value;
				}
			},

			u: function unmount() {
				div.innerHTML = '';

				detachNode(div);
			},

			d: noop
		};
	}

	function Post(options) {
		this._debugName = '<Post>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('post' in this._state)) console.warn("<Post> was created without expected data property 'post'");

		this._fragment = create_main_fragment$29(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Post.prototype, protoDev);

	Post.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/posts/PostDetails.html generated by Svelte v2.4.4 */

	function data$5() {
	  return {
	    starsActive: false,
	    commentsLink: '',
	    answersLink: ''
	  }
	}
	var methods$2 = {
	  addStar() {
	    var details = this.get().details,
	        active = this.get().starsActive;
	    details.stars = active ? details.stars - 1 : details.stars + 1;
	    this.set({
	      details,
	      starsActive: !active
	    });
	  }
	};

	function create_main_fragment$30(component, ctx) {
		var div, div_1, text_1, div_2, button, span;

		function select_block_type(ctx) {
			if (ctx.details) return create_if_block$5;
			return create_if_block_1$3;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		var iconssvg_initial_data = { name: "More" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		return {
			c: function create() {
				div = createElement("div");
				div_1 = createElement("div");
				if_block.c();
				text_1 = createText("\n\n  ");
				div_2 = createElement("div");
				button = createElement("button");
				span = createElement("span");
				iconssvg._fragment.c();
				div_1.className = "row";
				span.className = "icon svelte-1dw7j8z";
				button.className = "link svelte-1dw7j8z";
				div.className = "details row svelte-1dw7j8z";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				if_block.m(div_1, null);
				appendNode(text_1, div);
				appendNode(div_2, div);
				appendNode(button, div_2);
				appendNode(span, button);
				iconssvg._mount(span, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.u();
					if_block.d();
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div_1, null);
				}
			},

			u: function unmount() {
				detachNode(div);
				if_block.u();
			},

			d: function destroy$$1() {
				if_block.d();
				iconssvg.destroy(false);
			}
		};
	}

	// (3:4) {#if details}
	function create_if_block$5(component, ctx) {
		var button, span, text, span_1, text_1_value = ctx.details.stars > 0 ? ctx.details.stars : '', text_1, button_class_value, text_3, a, span_2, text_4, span_3, text_5_value = ctx.details.comments.total > 0 ? ctx.details.comments.total : '', text_5, a_href_value, text_7, a_1, span_4, text_8, span_5, text_9_value = ctx.details.answers.total > 0 ? ctx.details.answers.total : '', text_9, a_1_href_value;

		var iconssvg_initial_data = { name: "Star" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		function click_handler(event) {
			component.addStar();
		}

		var iconssvg_1_initial_data = { name: "MessageFull" };
		var iconssvg_1 = new IconsSvg({
			root: component.root,
			data: iconssvg_1_initial_data
		});

		var iconssvg_2_initial_data = { name: "Reply" };
		var iconssvg_2 = new IconsSvg({
			root: component.root,
			data: iconssvg_2_initial_data
		});

		return {
			c: function create() {
				button = createElement("button");
				span = createElement("span");
				iconssvg._fragment.c();
				text = createText("\n        ");
				span_1 = createElement("span");
				text_1 = createText(text_1_value);
				text_3 = createText("\n      ");
				a = createElement("a");
				span_2 = createElement("span");
				iconssvg_1._fragment.c();
				text_4 = createText("\n        ");
				span_3 = createElement("span");
				text_5 = createText(text_5_value);
				text_7 = createText("\n      ");
				a_1 = createElement("a");
				span_4 = createElement("span");
				iconssvg_2._fragment.c();
				text_8 = createText("\n        ");
				span_5 = createElement("span");
				text_9 = createText(text_9_value);
				span.className = "icon icon-star svelte-1dw7j8z";
				span_1.className = "text svelte-1dw7j8z";
				addListener(button, "click", click_handler);
				button.className = button_class_value = "link " + (ctx.starsActive ? 'active' : '') + " svelte-1dw7j8z";
				span_2.className = "icon icon-message svelte-1dw7j8z";
				span_3.className = "text svelte-1dw7j8z";
				a.className = "link svelte-1dw7j8z";
				a.href = a_href_value = ctx.details.comments.link;
				span_4.className = "icon svelte-1dw7j8z";
				span_5.className = "text svelte-1dw7j8z";
				a_1.className = "link svelte-1dw7j8z";
				a_1.href = a_1_href_value = ctx.details.answers.link;
			},

			m: function mount(target, anchor) {
				insertNode(button, target, anchor);
				appendNode(span, button);
				iconssvg._mount(span, null);
				appendNode(text, button);
				appendNode(span_1, button);
				appendNode(text_1, span_1);
				insertNode(text_3, target, anchor);
				insertNode(a, target, anchor);
				appendNode(span_2, a);
				iconssvg_1._mount(span_2, null);
				appendNode(text_4, a);
				appendNode(span_3, a);
				appendNode(text_5, span_3);
				insertNode(text_7, target, anchor);
				insertNode(a_1, target, anchor);
				appendNode(span_4, a_1);
				iconssvg_2._mount(span_4, null);
				appendNode(text_8, a_1);
				appendNode(span_5, a_1);
				appendNode(text_9, span_5);
			},

			p: function update(changed, ctx) {
				if ((changed.details) && text_1_value !== (text_1_value = ctx.details.stars > 0 ? ctx.details.stars : '')) {
					text_1.data = text_1_value;
				}

				if ((changed.starsActive) && button_class_value !== (button_class_value = "link " + (ctx.starsActive ? 'active' : '') + " svelte-1dw7j8z")) {
					button.className = button_class_value;
				}

				if ((changed.details) && text_5_value !== (text_5_value = ctx.details.comments.total > 0 ? ctx.details.comments.total : '')) {
					text_5.data = text_5_value;
				}

				if ((changed.details) && a_href_value !== (a_href_value = ctx.details.comments.link)) {
					a.href = a_href_value;
				}

				if ((changed.details) && text_9_value !== (text_9_value = ctx.details.answers.total > 0 ? ctx.details.answers.total : '')) {
					text_9.data = text_9_value;
				}

				if ((changed.details) && a_1_href_value !== (a_1_href_value = ctx.details.answers.link)) {
					a_1.href = a_1_href_value;
				}
			},

			u: function unmount() {
				detachNode(button);
				detachNode(text_3);
				detachNode(a);
				detachNode(text_7);
				detachNode(a_1);
			},

			d: function destroy$$1() {
				iconssvg.destroy(false);
				removeListener(button, "click", click_handler);
				iconssvg_1.destroy(false);
				iconssvg_2.destroy(false);
			}
		};
	}

	// (16:4) {:else}
	function create_if_block_1$3(component, ctx) {
		var button, span, text, span_1, button_class_value, text_2, a, span_2, text_3, span_3, text_5, a_1, span_4, text_6, span_5;

		var iconssvg_initial_data = { name: "Star" };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		function click_handler(event) {
			component.addStar();
		}

		var iconssvg_1_initial_data = { name: "MessageFull" };
		var iconssvg_1 = new IconsSvg({
			root: component.root,
			data: iconssvg_1_initial_data
		});

		var iconssvg_2_initial_data = { name: "Reply" };
		var iconssvg_2 = new IconsSvg({
			root: component.root,
			data: iconssvg_2_initial_data
		});

		return {
			c: function create() {
				button = createElement("button");
				span = createElement("span");
				iconssvg._fragment.c();
				text = createText("\n        ");
				span_1 = createElement("span");
				text_2 = createText("\n      ");
				a = createElement("a");
				span_2 = createElement("span");
				iconssvg_1._fragment.c();
				text_3 = createText("\n        ");
				span_3 = createElement("span");
				text_5 = createText("\n      ");
				a_1 = createElement("a");
				span_4 = createElement("span");
				iconssvg_2._fragment.c();
				text_6 = createText("\n        ");
				span_5 = createElement("span");
				span.className = "icon icon-star svelte-1dw7j8z";
				span_1.className = "text svelte-1dw7j8z";
				addListener(button, "click", click_handler);
				button.className = button_class_value = "link " + (ctx.starsActive ? 'active' : '') + " svelte-1dw7j8z";
				span_2.className = "icon icon-message svelte-1dw7j8z";
				span_3.className = "text svelte-1dw7j8z";
				a.className = "link svelte-1dw7j8z";
				a.href = ctx.commentsLink;
				span_4.className = "icon svelte-1dw7j8z";
				span_5.className = "text svelte-1dw7j8z";
				a_1.className = "link svelte-1dw7j8z";
				a_1.href = ctx.answersLink;
			},

			m: function mount(target, anchor) {
				insertNode(button, target, anchor);
				appendNode(span, button);
				iconssvg._mount(span, null);
				appendNode(text, button);
				appendNode(span_1, button);
				insertNode(text_2, target, anchor);
				insertNode(a, target, anchor);
				appendNode(span_2, a);
				iconssvg_1._mount(span_2, null);
				appendNode(text_3, a);
				appendNode(span_3, a);
				insertNode(text_5, target, anchor);
				insertNode(a_1, target, anchor);
				appendNode(span_4, a_1);
				iconssvg_2._mount(span_4, null);
				appendNode(text_6, a_1);
				appendNode(span_5, a_1);
			},

			p: function update(changed, ctx) {
				if ((changed.starsActive) && button_class_value !== (button_class_value = "link " + (ctx.starsActive ? 'active' : '') + " svelte-1dw7j8z")) {
					button.className = button_class_value;
				}

				if (changed.commentsLink) {
					a.href = ctx.commentsLink;
				}

				if (changed.answersLink) {
					a_1.href = ctx.answersLink;
				}
			},

			u: function unmount() {
				detachNode(button);
				detachNode(text_2);
				detachNode(a);
				detachNode(text_5);
				detachNode(a_1);
			},

			d: function destroy$$1() {
				iconssvg.destroy(false);
				removeListener(button, "click", click_handler);
				iconssvg_1.destroy(false);
				iconssvg_2.destroy(false);
			}
		};
	}

	function PostDetails(options) {
		this._debugName = '<PostDetails>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$5(), options.data);
		if (!('details' in this._state)) console.warn("<PostDetails> was created without expected data property 'details'");
		if (!('starsActive' in this._state)) console.warn("<PostDetails> was created without expected data property 'starsActive'");
		if (!('commentsLink' in this._state)) console.warn("<PostDetails> was created without expected data property 'commentsLink'");
		if (!('answersLink' in this._state)) console.warn("<PostDetails> was created without expected data property 'answersLink'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$30(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(PostDetails.prototype, protoDev);
	assign(PostDetails.prototype, methods$2);

	PostDetails.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/profile/content/ProfileFeed.html generated by Svelte v2.4.4 */

	function data$6() {
	  return {
	    isReview: false,
	    reviewUser: ''
	  }
	}
	function create_main_fragment$31(component, ctx) {
		var each_anchor;

		var each_value = ctx.profile.posts;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(component, get_each_context$3(ctx, each_value, i));
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insertNode(each_anchor, target, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.profile || changed.user) {
					each_value = ctx.profile.posts;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$3(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = each_value.length;
				}
			},

			u: function unmount() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}

				detachNode(each_anchor);
			},

			d: function destroy$$1() {
				destroyEach(each_blocks);
			}
		};
	}

	// (1:0) {#each profile.posts as post}
	function create_each_block$3(component, ctx) {
		var article, text, div, text_1, text_2, article_class_value;

		function select_block_type(ctx) {
			if (ctx.post.isReview) return create_if_block$6;
			return create_if_block_1$4;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		function select_block_type_1(ctx) {
			if (ctx.post.isReview) return create_if_block_2$2;
			return create_if_block_3;
		}

		var current_block_type_1 = select_block_type_1(ctx);
		var if_block_1 = current_block_type_1(component, ctx);

		function select_block_type_2(ctx) {
			if (ctx.post.isReview) return create_if_block_4;
			if (ctx.post.isSponsored) return create_if_block_5;
			return create_if_block_6;
		}

		var current_block_type_2 = select_block_type_2(ctx);
		var if_block_2 = current_block_type_2(component, ctx);

		var postdetails_initial_data = { details: ctx.post.details };
		var postdetails = new PostDetails({
			root: component.root,
			data: postdetails_initial_data
		});

		return {
			c: function create() {
				article = createElement("article");
				if_block.c();
				text = createText("\n\n    ");
				div = createElement("div");
				if_block_1.c();
				text_1 = createText("\n\n      ");
				if_block_2.c();
				text_2 = createText("\n\n      ");
				postdetails._fragment.c();
				div.className = "content svelte-1e1v44j";
				article.className = article_class_value = "post " + (ctx.post.isSponsored ? 'sponsored' : '') + " svelte-1e1v44j";
			},

			m: function mount(target, anchor) {
				insertNode(article, target, anchor);
				if_block.m(article, null);
				appendNode(text, article);
				appendNode(div, article);
				if_block_1.m(div, null);
				appendNode(text_1, div);
				if_block_2.m(div, null);
				appendNode(text_2, div);
				postdetails._mount(div, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.u();
					if_block.d();
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(article, text);
				}

				if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block_1) {
					if_block_1.p(changed, ctx);
				} else {
					if_block_1.u();
					if_block_1.d();
					if_block_1 = current_block_type_1(component, ctx);
					if_block_1.c();
					if_block_1.m(div, text_1);
				}

				if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block_2) {
					if_block_2.p(changed, ctx);
				} else {
					if_block_2.u();
					if_block_2.d();
					if_block_2 = current_block_type_2(component, ctx);
					if_block_2.c();
					if_block_2.m(div, text_2);
				}

				var postdetails_changes = {};
				if (changed.profile) postdetails_changes.details = ctx.post.details;
				postdetails._set(postdetails_changes);

				if ((changed.profile) && article_class_value !== (article_class_value = "post " + (ctx.post.isSponsored ? 'sponsored' : '') + " svelte-1e1v44j")) {
					article.className = article_class_value;
				}
			},

			u: function unmount() {
				detachNode(article);
				if_block.u();
				if_block_1.u();
				if_block_2.u();
			},

			d: function destroy$$1() {
				if_block.d();
				if_block_1.d();
				if_block_2.d();
				postdetails.destroy(false);
			}
		};
	}

	// (3:4) {#if post.isReview}
	function create_if_block$6(component, ctx) {

		var avatar_initial_data = { isReview: "true", user: ctx.post.review.user };
		var avatar = new Avatar({
			root: component.root,
			data: avatar_initial_data
		});

		return {
			c: function create() {
				avatar._fragment.c();
			},

			m: function mount(target, anchor) {
				avatar._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var avatar_changes = {};
				if (changed.profile) avatar_changes.user = ctx.post.review.user;
				avatar._set(avatar_changes);
			},

			u: function unmount() {
				avatar._unmount();
			},

			d: function destroy$$1() {
				avatar.destroy(false);
			}
		};
	}

	// (5:4) {:else}
	function create_if_block_1$4(component, ctx) {

		var avatar_initial_data = { user: ctx.user };
		var avatar = new Avatar({
			root: component.root,
			data: avatar_initial_data
		});

		return {
			c: function create() {
				avatar._fragment.c();
			},

			m: function mount(target, anchor) {
				avatar._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var avatar_changes = {};
				if (changed.user) avatar_changes.user = ctx.user;
				avatar._set(avatar_changes);
			},

			u: function unmount() {
				avatar._unmount();
			},

			d: function destroy$$1() {
				avatar.destroy(false);
			}
		};
	}

	// (10:6) {#if post.isReview}
	function create_if_block_2$2(component, ctx) {

		var posttitle_initial_data = {
		 	isReview: "true",
		 	user: ctx.post.review.user,
		 	date: ctx.post.date
		 };
		var posttitle = new PostTitle({
			root: component.root,
			data: posttitle_initial_data
		});

		return {
			c: function create() {
				posttitle._fragment.c();
			},

			m: function mount(target, anchor) {
				posttitle._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var posttitle_changes = {};
				if (changed.profile) posttitle_changes.user = ctx.post.review.user;
				if (changed.profile) posttitle_changes.date = ctx.post.date;
				posttitle._set(posttitle_changes);
			},

			u: function unmount() {
				posttitle._unmount();
			},

			d: function destroy$$1() {
				posttitle.destroy(false);
			}
		};
	}

	// (12:6) {:else}
	function create_if_block_3(component, ctx) {

		var posttitle_initial_data = {
		 	isSponsored: ctx.post.isSponsored,
		 	user: ctx.user,
		 	date: ctx.post.date
		 };
		var posttitle = new PostTitle({
			root: component.root,
			data: posttitle_initial_data
		});

		return {
			c: function create() {
				posttitle._fragment.c();
			},

			m: function mount(target, anchor) {
				posttitle._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var posttitle_changes = {};
				if (changed.profile) posttitle_changes.isSponsored = ctx.post.isSponsored;
				if (changed.user) posttitle_changes.user = ctx.user;
				if (changed.profile) posttitle_changes.date = ctx.post.date;
				posttitle._set(posttitle_changes);
			},

			u: function unmount() {
				posttitle._unmount();
			},

			d: function destroy$$1() {
				posttitle.destroy(false);
			}
		};
	}

	// (16:6) {#if post.isReview}
	function create_if_block_4(component, ctx) {

		var reviewpost_initial_data = {
		 	post: ctx.post,
		 	user: ctx.user,
		 	rating: ctx.profile.details.rating
		 };
		var reviewpost = new ReviewPost({
			root: component.root,
			data: reviewpost_initial_data
		});

		return {
			c: function create() {
				reviewpost._fragment.c();
			},

			m: function mount(target, anchor) {
				reviewpost._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var reviewpost_changes = {};
				if (changed.profile) reviewpost_changes.post = ctx.post;
				if (changed.user) reviewpost_changes.user = ctx.user;
				if (changed.profile) reviewpost_changes.rating = ctx.profile.details.rating;
				reviewpost._set(reviewpost_changes);
			},

			u: function unmount() {
				reviewpost._unmount();
			},

			d: function destroy$$1() {
				reviewpost.destroy(false);
			}
		};
	}

	// (18:32) 
	function create_if_block_5(component, ctx) {

		var sponsoredpost_initial_data = { post: ctx.post };
		var sponsoredpost = new SponsoredPost({
			root: component.root,
			data: sponsoredpost_initial_data
		});

		return {
			c: function create() {
				sponsoredpost._fragment.c();
			},

			m: function mount(target, anchor) {
				sponsoredpost._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var sponsoredpost_changes = {};
				if (changed.profile) sponsoredpost_changes.post = ctx.post;
				sponsoredpost._set(sponsoredpost_changes);
			},

			u: function unmount() {
				sponsoredpost._unmount();
			},

			d: function destroy$$1() {
				sponsoredpost.destroy(false);
			}
		};
	}

	// (20:6) {:else}
	function create_if_block_6(component, ctx) {

		var post_initial_data = { post: ctx.post };
		var post = new Post({
			root: component.root,
			data: post_initial_data
		});

		return {
			c: function create() {
				post._fragment.c();
			},

			m: function mount(target, anchor) {
				post._mount(target, anchor);
			},

			p: function update(changed, ctx) {
				var post_changes = {};
				if (changed.profile) post_changes.post = ctx.post;
				post._set(post_changes);
			},

			u: function unmount() {
				post._unmount();
			},

			d: function destroy$$1() {
				post.destroy(false);
			}
		};
	}

	function get_each_context$3(ctx, list, i) {
		return assign(assign({}, ctx), {
			post: list[i],
			each_value: list,
			post_index: i
		});
	}

	function ProfileFeed(options) {
		this._debugName = '<ProfileFeed>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$6(), options.data);
		if (!('profile' in this._state)) console.warn("<ProfileFeed> was created without expected data property 'profile'");
		if (!('user' in this._state)) console.warn("<ProfileFeed> was created without expected data property 'user'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$31(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(ProfileFeed.prototype, protoDev);

	ProfileFeed.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/profile/content/ProfileAgenda.html generated by Svelte v2.4.4 */

	function create_main_fragment$32(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Profile Agenda");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function ProfileAgenda(options) {
		this._debugName = '<ProfileAgenda>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$32(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProfileAgenda.prototype, protoDev);

	ProfileAgenda.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/profile/content/ProfileResume.html generated by Svelte v2.4.4 */

	function create_main_fragment$33(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Profile Resume");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function ProfileResume(options) {
		this._debugName = '<ProfileResume>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$33(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProfileResume.prototype, protoDev);

	ProfileResume.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/profile/ContentProfile.html generated by Svelte v2.4.4 */

	var components = {
	  ProfileInfo,
	  ProfileFeed,
	  ProfileAgenda,
	  ProfileResume
	};

	function data$7() {
	  return {
	    selected: ProfileFeed
	  }
	}
	var methods$3 = {
	  toggleContent(i) {
	    var menu = this.get().menu;
	    var clicked = menu[i];
	    if (clicked.active) { return; }
	    var activeItem = menu.find(x => x.active === true);
	    activeItem.active = '';
	    clicked.active = true;
	    this.set({menu});
	    var selected = components[clicked.link];
	    if (selected) this.set({selected});
	    else {
	      console.log('error: missing ContentProfile component');
	    }
	  }
	};

	function create_main_fragment$34(component, ctx) {
		var nav, ul, ul_class_value, text_1, div;

		var each_value = ctx.menu;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(component, get_each_context$4(ctx, each_value, i));
		}

		var switch_value = ctx.selected;

		function switch_props(ctx) {
			var switch_instance_initial_data = { profile: ctx.profile, user: ctx.user };
			return {
				root: component.root,
				data: switch_instance_initial_data
			};
		}

		if (switch_value) {
			var switch_instance = new switch_value(switch_props(ctx));
		}

		return {
			c: function create() {
				nav = createElement("nav");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_1 = createText("\n\n");
				div = createElement("div");
				if (switch_instance) switch_instance._fragment.c();
				ul.className = ul_class_value = "tab-nav animate " + (ctx.animate ? 'scaleY' : '') + " svelte-zza7p5";
				div.className = "tab-content svelte-zza7p5";
			},

			m: function mount(target, anchor) {
				insertNode(nav, target, anchor);
				appendNode(ul, nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				insertNode(text_1, target, anchor);
				insertNode(div, target, anchor);

				if (switch_instance) {
					switch_instance._mount(div, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.menu) {
					each_value = ctx.menu;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$4(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = each_value.length;
				}

				if ((changed.animate) && ul_class_value !== (ul_class_value = "tab-nav animate " + (ctx.animate ? 'scaleY' : '') + " svelte-zza7p5")) {
					ul.className = ul_class_value;
				}

				var switch_instance_changes = {};
				if (changed.profile) switch_instance_changes.profile = ctx.profile;
				if (changed.user) switch_instance_changes.user = ctx.user;

				if (switch_value !== (switch_value = ctx.selected)) {
					if (switch_instance) switch_instance.destroy();

					if (switch_value) {
						switch_instance = new switch_value(switch_props(ctx));
						switch_instance._fragment.c();
						switch_instance._mount(div, null);
					}
				}

				else if (switch_value) {
					switch_instance._set(switch_instance_changes);
				}
			},

			u: function unmount() {
				detachNode(nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}

				detachNode(text_1);
				detachNode(div);
			},

			d: function destroy$$1() {
				destroyEach(each_blocks);

				if (switch_instance) switch_instance.destroy(false);
			}
		};
	}

	// (3:4) {#each menu as item, i}
	function create_each_block$4(component, ctx) {
		var li, button, text, span, text_1_value = ctx.item.icon.text, text_1, button_class_value;

		function select_block_type(ctx) {
			if (ctx.item.icon.svg) return create_if_block$7;
			if (ctx.item.icon.img) return create_if_block_1$5;
			return create_if_block_2$3;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				li = createElement("li");
				button = createElement("button");
				if_block.c();
				text = createText("\n        ");
				span = createElement("span");
				text_1 = createText(text_1_value);
				span.className = "text svelte-zza7p5";

				button._svelte = { component, ctx };

				addListener(button, "click", click_handler);
				button.className = button_class_value = "btn menu-item " + (ctx.item.active ? 'active' : '') + " svelte-zza7p5";
				li.className = "svelte-zza7p5";
			},

			m: function mount(target, anchor) {
				insertNode(li, target, anchor);
				appendNode(button, li);
				if_block.m(button, null);
				appendNode(text, button);
				appendNode(span, button);
				appendNode(text_1, span);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.u();
					if_block.d();
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(button, text);
				}

				if ((changed.menu) && text_1_value !== (text_1_value = ctx.item.icon.text)) {
					text_1.data = text_1_value;
				}

				button._svelte.ctx = ctx;
				if ((changed.menu) && button_class_value !== (button_class_value = "btn menu-item " + (ctx.item.active ? 'active' : '') + " svelte-zza7p5")) {
					button.className = button_class_value;
				}
			},

			u: function unmount() {
				detachNode(li);
				if_block.u();
			},

			d: function destroy$$1() {
				if_block.d();
				removeListener(button, "click", click_handler);
			}
		};
	}

	// (6:8) {#if item.icon.svg}
	function create_if_block$7(component, ctx) {
		var span;

		var iconssvg_initial_data = { name: ctx.item.icon.svg };
		var iconssvg = new IconsSvg({
			root: component.root,
			data: iconssvg_initial_data
		});

		return {
			c: function create() {
				span = createElement("span");
				iconssvg._fragment.c();
				span.className = "icon svelte-zza7p5";
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
				iconssvg._mount(span, null);
			},

			p: function update(changed, ctx) {
				var iconssvg_changes = {};
				if (changed.menu) iconssvg_changes.name = ctx.item.icon.svg;
				iconssvg._set(iconssvg_changes);
			},

			u: function unmount() {
				detachNode(span);
			},

			d: function destroy$$1() {
				iconssvg.destroy(false);
			}
		};
	}

	// (10:31) 
	function create_if_block_1$5(component, ctx) {
		var span, img, img_src_value, img_alt_value;

		return {
			c: function create() {
				span = createElement("span");
				img = createElement("img");
				img.src = img_src_value = ctx.item.icon.img;
				img.alt = img_alt_value = ctx.item.icon.name;
				span.className = "icon svelte-zza7p5";
			},

			m: function mount(target, anchor) {
				insertNode(span, target, anchor);
				appendNode(img, span);
			},

			p: function update(changed, ctx) {
				if ((changed.menu) && img_src_value !== (img_src_value = ctx.item.icon.img)) {
					img.src = img_src_value;
				}

				if ((changed.menu) && img_alt_value !== (img_alt_value = ctx.item.icon.name)) {
					img.alt = img_alt_value;
				}
			},

			u: function unmount() {
				detachNode(span);
			},

			d: noop
		};
	}

	// (14:8) {:else}
	function create_if_block_2$3(component, ctx) {
		var text_value = ctx.item.icon.name, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.menu) && text_value !== (text_value = ctx.item.icon.name)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function get_each_context$4(ctx, list, i) {
		return assign(assign({}, ctx), {
			item: list[i],
			each_value: list,
			i: i
		});
	}

	function click_handler(event) {
		const { component, ctx } = this._svelte;

		component.toggleContent(ctx.i);
	}

	function ContentProfile(options) {
		this._debugName = '<ContentProfile>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$7(), options.data);
		if (!('animate' in this._state)) console.warn("<ContentProfile> was created without expected data property 'animate'");
		if (!('menu' in this._state)) console.warn("<ContentProfile> was created without expected data property 'menu'");
		if (!('selected' in this._state)) console.warn("<ContentProfile> was created without expected data property 'selected'");
		if (!('profile' in this._state)) console.warn("<ContentProfile> was created without expected data property 'profile'");
		if (!('user' in this._state)) console.warn("<ContentProfile> was created without expected data property 'user'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$34(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(ContentProfile.prototype, protoDev);
	assign(ContentProfile.prototype, methods$3);

	ContentProfile.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/SidebarContent.html generated by Svelte v2.4.4 */

	function create_main_fragment$35(component, ctx) {
		var main, slot_content_default = component._slotted.default, h2, text_2, h2_1;

		return {
			c: function create() {
				main = createElement("main");
				if (!slot_content_default) {
					h2 = createElement("h2");
					h2.innerHTML = "Today Highlight <a class=\"right link\" href=\"/\">More</a>";
					text_2 = createText("\n    ");
					h2_1 = createElement("h2");
					h2_1.innerHTML = "Who to Follow <a class=\"right link\" href=\"/\">More</a>";
				}
				if (!slot_content_default) {
					h2.className = "title";
					h2_1.className = "title";
				}
				main.className = "svelte-18sdog";
			},

			m: function mount(target, anchor) {
				insertNode(main, target, anchor);
				if (!slot_content_default) {
					appendNode(h2, main);
					appendNode(text_2, main);
					appendNode(h2_1, main);
				}

				else {
					appendNode(slot_content_default, main);
				}
			},

			p: noop,

			u: function unmount() {
				detachNode(main);

				if (slot_content_default) {
					reinsertChildren(main, slot_content_default);
				}
			},

			d: noop
		};
	}

	function SidebarContent(options) {
		this._debugName = '<SidebarContent>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._slotted = options.slots || {};

		this.slots = {};

		this._fragment = create_main_fragment$35(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SidebarContent.prototype, protoDev);

	SidebarContent.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/App.html generated by Svelte v2.4.4 */

	// style values
	const BANNER_H = 360;
	const PROFILE_IMG_H = 225;
	const SCROLL_SPACE_SIDEBAR = BANNER_H - PROFILE_IMG_H/2;

	// data values
	const POSTS = [
		{ post_id: '',
			date: '2018-05-09T12:00:00Z',
			content: {
				text: '<p>New portfolio update with my last projects <strong>#architecture</strong> <strong>#portfolio</strong> <a class="link" href="https://www.architizes.com/MarioMendez" target="_blank">https://www.architizes.com/MarioMendez</a></p>'
			},
			details: {
				stars: 2,
				comments: {
					total: 11,
					link: ''
				},
				answers: {
					total: 0,
					link: ''
				}
			}
		},
		{ post_id: '',
			isSponsored: true,
			date: '2018-05-06T13:00:00Z',
			content: {
				text: '<p><strong>Architecture Services</strong></p><p>Design and planning consultance, see more at ...<p>',
				img: 'https://i.imgur.com/vZ8suUE.jpg'
			},
			details: {
				stars: 36,
				comments: {
					total: 2,
					link: ''
				},
				answers: {
					total: 5,
					link: ''
				}
			},
			recommendations: {
				// would be an array of 42 elements/users id
				users: ['03', '04', '05', '10', '11'],
				rating: 4.6,
				// total = users.length
				total: 42
			}
		},
		{	post_id: '001',
			isReview: true,
			date: '2018-05-03T13:00:00Z',
			review: {
				user: '03',
				content: {
					text: 'It was a pleasure to work with Mario. Very professional and talented architect. I really suggest him!'
				},
				rating: 5,
			},
			details: {
				stars: 6,
				comments: {
					total: 2,
					link: ''
				},
				answers: {
					total: 2,
					link: ''
				}
			}
		},
		{	post_id: '002',
			isReview: true,
			date: '2018-05-02T14:00:00Z',
			review: {
				user: '04',
				content: {
					text: 'I worked with him for a project ...'
				},
				rating: 5,
			}
		},
		{	post_id: '003',
			isReview: true,
			date: '2018-05-01T14:00:00Z',
			review: {
				user: '05',
				content: {
					text: 'I contacted him for a project ...'
				},
				rating: 4,
			}
		}
	];

	const REVIEWS = [];

	const PROJECTS = [
		{img: 'https://i.imgur.com/vZ8suUE.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/kKvl97S.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/6fQwQdQ.png', title: 'title', link: ''},
		{img: 'https://i.imgur.com/6eA8rHj.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/HZVeVDs.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/3JueZBg.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/mucT2Sl.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/tA6OlVu.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/w1bEuVW.jpg', title: 'title', link: ''},
		{img: 'https://i.imgur.com/V2Mt6RJ.jpg', title: 'title', link: ''}
	];

	const PROFILE = {
		details: {
			rating: 4.8,
			followers: 320,
			following: 147,
			perf: 56,
			reviews: 42,
		},
		banner: {
			img: 'https://i.imgur.com/MbMnM74.jpg',
			width: 130,
			top: -60,
			left: 0
		},
		projects: PROJECTS,
		posts: POSTS,
		reviews: REVIEWS
	};

	const ICONS = [
		{name: 'search', color: '#42A5D2', svg: 'Search'},
		{name: 'edit', color: '#FDAA29', svg: 'Edit'},
		{name: 'messages', color: '#F26C4F', svg: 'Message'},
		{name: 'agenda', color: '#058E85', svg: 'Agenda', 'text': 'Agenda'},
		{name: 'info', svg: 'Clipboard', text: 'Info'},
		{name: 'feed', svg: 'Book', text: 'Feed'},
		{name: 'resume', svg: 'Clip', text: 'Rsum'},
	];

	function data$8() {
		return {
			brand: {img: '', link: ''},
			icons: ICONS,
			mainNav: [
				{link: '', icon: 'search', active: true},
				{link: '', icon: 'edit'},
				{link: '', icon: 'messages'},
				{link: '', icon: 'agenda'}
			],
			profileMenu: [
				{link: 'ProfileInfo', icon: 'info'},
				{link: 'ProfileFeed', icon: 'feed', active: true},
				{link: 'ProfileAgenda', icon: 'agenda'},
				{link: 'ProfileResume', icon: 'resume'}
			],
			user: '',
			userId: '01',
			profileUser: '',
			profileId: '02',
			profile: PROFILE,
			// style data
			fixedHeader: false,
			blur: 0,
			dim: 225,
			animate: false,
			lastScrollTop: 0
		}
	}
	var methods$4 = {
		getIcons(menu) {
			var icons = this.get().icons;
			if (menu.length === 0) return;
			menu.forEach(item => {
				var found = icons.find(x => x.name === item.icon);
				if (found) item.icon = found;
				else item.icon = {name: item.icon};
			});
			return menu;
		},
		setUser(id) {
			if (!id) {
				console.log('missing user id', this);
				return;
			}
			var user = api.findUser(id);
			if (!user) console.log('no user with id ', id, this);
			else this.set({user});
		},
		setProfileUser(id) {
			if (!id) {
				console.log('missing profile user id', this);
				return;
			}
			var profileUser = api.findUser(id);
			if (!profileUser) console.log('no profile user with id ', id, this);
			else this.set({profileUser});
		},
		scrollAnimation(event) {
			var scrollTop = event.target.scrollTop;
			if (scrollTop > BANNER_H && this.get().fixedHeader) { return; }

			// banner animation
			this.set({blur: scrollTop*6/BANNER_H});

			// header animation
			if (scrollTop === BANNER_H) {
				this.set({fixedHeader: true});
			} else if (scrollTop < BANNER_H && this.get().fixedHeader) {
				this.set({fixedHeader: false});
			}

			// profile image animation
			if (scrollTop > SCROLL_SPACE_SIDEBAR && scrollTop > this.get().lastScrollTop) {
				this.set({animate: true});
				event.target.scroll({top: BANNER_H, left: 0, behavior: 'smooth' });
			}
			else if (this.get().fixedHeader) {
				this.set({animate: true});
			}
			else if (!this.get().fixedHeader){
				this.set({animate: false});
			}
			this.set({lastScrollTop: scrollTop});
		}
	};

	function oncreate$5() {
		this.setUser(this.get().userId);
		this.setProfileUser(this.get().profileId);

		this.set({mainNav: this.getIcons(this.get().mainNav)});
		this.set({profileMenu: this.getIcons(this.get().profileMenu)});
	}
	function create_main_fragment$36(component, ctx) {
		var link, text, div, text_1, div_1, text_2, div_2, text_3, div_3, text_4, text_5, text_6, main, text_7, div_4, div_5, text_9, text_10, text_11;

		var sidenav_initial_data = {
		 	menu: ctx.mainNav,
		 	brand: ctx.brand,
		 	user: ctx.user
		 };
		var sidenav = new SideNav({
			root: component.root,
			data: sidenav_initial_data
		});

		var banner_initial_data = { banner: ctx.profile.banner, blur: ctx.blur };
		var banner = new Banner({
			root: component.root,
			data: banner_initial_data
		});

		var sidebarprofile_initial_data = {
		 	profile: ctx.profile,
		 	user: ctx.profileUser,
		 	animate: ctx.animate,
		 	fixed: ctx.fixedHeader
		 };
		var sidebarprofile = new SidebarProfile({
			root: component.root,
			data: sidebarprofile_initial_data
		});

		var sidebar = new Sidebar({
			root: component.root,
			slots: { default: createFragment() }
		});

		var headerprofile_initial_data = {
		 	profile: ctx.profile,
		 	user: ctx.profileUser,
		 	fixed: ctx.fixedHeader
		 };
		var headerprofile = new HeaderProfile({
			root: component.root,
			data: headerprofile_initial_data
		});

		var contentprofile_initial_data = {
		 	menu: ctx.profileMenu,
		 	profile: ctx.profile,
		 	user: ctx.profileUser,
		 	animate: ctx.animate
		 };
		var contentprofile = new ContentProfile({
			root: component.root,
			data: contentprofile_initial_data
		});

		var sidebarcontent = new SidebarContent({
			root: component.root
		});

		var sidebar_1 = new Sidebar({
			root: component.root,
			slots: { default: createFragment() }
		});

		function scroll_handler(event) {
			component.scrollAnimation(event);
		}

		return {
			c: function create() {
				link = createElement("link");
				text = createText("\n\n");
				div = createElement("div");
				sidenav._fragment.c();
				text_1 = createText("\n\n\t");
				div_1 = createElement("div");
				banner._fragment.c();
				text_2 = createText("\n\t\t");
				div_2 = createElement("div");
				text_3 = createText("\n\t\t");
				div_3 = createElement("div");
				text_4 = createText("\n\t\t\t\t");
				sidebarprofile._fragment.c();
				text_5 = createText("\n\t\t\t");
				sidebar._fragment.c();
				text_6 = createText("\n\t\t\t");
				main = createElement("main");
				headerprofile._fragment.c();
				text_7 = createText("\n\t\t\t\t");
				div_4 = createElement("div");
				div_5 = createElement("div");
				contentprofile._fragment.c();
				text_9 = createText("\n\t\t\t\t\t");
				text_10 = createText("\n\t\t\t\t\t\t");
				sidebarcontent._fragment.c();
				text_11 = createText("\n\t\t\t\t\t");
				sidebar_1._fragment.c();
				link.href = "https://fonts.googleapis.com/css?family=Palanquin:300";
				link.rel = "stylesheet";
				div_2.className = "scroll-space svelte-y15pki";
				div_5.className = "content svelte-y15pki";
				div_4.className = "row";
				main.className = "svelte-y15pki";
				div_3.className = "row scroll-content svelte-y15pki";
				addListener(div_1, "scroll", scroll_handler);
				div_1.className = "scroll svelte-y15pki";
				div.className = "page sidenav svelte-y15pki";
			},

			m: function mount(target, anchor) {
				appendNode(link, document.head);
				insertNode(text, target, anchor);
				insertNode(div, target, anchor);
				sidenav._mount(div, null);
				appendNode(text_1, div);
				appendNode(div_1, div);
				banner._mount(div_1, null);
				appendNode(text_2, div_1);
				appendNode(div_2, div_1);
				appendNode(text_3, div_1);
				appendNode(div_3, div_1);
				appendNode(text_4, sidebar._slotted.default);
				sidebarprofile._mount(sidebar._slotted.default, null);
				appendNode(text_5, sidebar._slotted.default);
				sidebar._mount(div_3, null);
				appendNode(text_6, div_3);
				appendNode(main, div_3);
				headerprofile._mount(main, null);
				appendNode(text_7, main);
				appendNode(div_4, main);
				appendNode(div_5, div_4);
				contentprofile._mount(div_5, null);
				appendNode(text_9, div_4);
				appendNode(text_10, sidebar_1._slotted.default);
				sidebarcontent._mount(sidebar_1._slotted.default, null);
				appendNode(text_11, sidebar_1._slotted.default);
				sidebar_1._mount(div_4, null);
			},

			p: function update(changed, ctx) {
				var sidenav_changes = {};
				if (changed.mainNav) sidenav_changes.menu = ctx.mainNav;
				if (changed.brand) sidenav_changes.brand = ctx.brand;
				if (changed.user) sidenav_changes.user = ctx.user;
				sidenav._set(sidenav_changes);

				var banner_changes = {};
				if (changed.profile) banner_changes.banner = ctx.profile.banner;
				if (changed.blur) banner_changes.blur = ctx.blur;
				banner._set(banner_changes);

				var sidebarprofile_changes = {};
				if (changed.profile) sidebarprofile_changes.profile = ctx.profile;
				if (changed.profileUser) sidebarprofile_changes.user = ctx.profileUser;
				if (changed.animate) sidebarprofile_changes.animate = ctx.animate;
				if (changed.fixedHeader) sidebarprofile_changes.fixed = ctx.fixedHeader;
				sidebarprofile._set(sidebarprofile_changes);

				var headerprofile_changes = {};
				if (changed.profile) headerprofile_changes.profile = ctx.profile;
				if (changed.profileUser) headerprofile_changes.user = ctx.profileUser;
				if (changed.fixedHeader) headerprofile_changes.fixed = ctx.fixedHeader;
				headerprofile._set(headerprofile_changes);

				var contentprofile_changes = {};
				if (changed.profileMenu) contentprofile_changes.menu = ctx.profileMenu;
				if (changed.profile) contentprofile_changes.profile = ctx.profile;
				if (changed.profileUser) contentprofile_changes.user = ctx.profileUser;
				if (changed.animate) contentprofile_changes.animate = ctx.animate;
				contentprofile._set(contentprofile_changes);
			},

			u: function unmount() {
				detachNode(link);
				detachNode(text);
				detachNode(div);
			},

			d: function destroy$$1() {
				sidenav.destroy(false);
				banner.destroy(false);
				sidebarprofile.destroy(false);
				sidebar.destroy(false);
				headerprofile.destroy(false);
				contentprofile.destroy(false);
				sidebarcontent.destroy(false);
				sidebar_1.destroy(false);
				removeListener(div_1, "scroll", scroll_handler);
			}
		};
	}

	function App(options) {
		this._debugName = '<App>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$8(), options.data);
		if (!('mainNav' in this._state)) console.warn("<App> was created without expected data property 'mainNav'");
		if (!('brand' in this._state)) console.warn("<App> was created without expected data property 'brand'");
		if (!('user' in this._state)) console.warn("<App> was created without expected data property 'user'");
		if (!('profile' in this._state)) console.warn("<App> was created without expected data property 'profile'");
		if (!('blur' in this._state)) console.warn("<App> was created without expected data property 'blur'");
		if (!('profileUser' in this._state)) console.warn("<App> was created without expected data property 'profileUser'");
		if (!('animate' in this._state)) console.warn("<App> was created without expected data property 'animate'");
		if (!('fixedHeader' in this._state)) console.warn("<App> was created without expected data property 'fixedHeader'");
		if (!('profileMenu' in this._state)) console.warn("<App> was created without expected data property 'profileMenu'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$36(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$5.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(App.prototype, protoDev);
	assign(App.prototype, methods$4);

	App.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	var app = new App({
		target: document.body,
		data: {}
	});

	return app;

}());
//# sourceMappingURL=bundle.js.map
