var app = (function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function reinsertChildren(parent, target) {
		while (parent.firstChild) target.appendChild(parent.firstChild);
	}

	function reinsertAfter(before, target) {
		while (before.nextSibling) target.appendChild(before.nextSibling);
	}

	function reinsertBefore(after, target) {
		var parent = after.parentNode;
		while (parent.firstChild !== after) target.appendChild(parent.firstChild);
	}

	function destroyEach(iterations) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d();
		}
	}

	function createFragment() {
		return document.createDocumentFragment();
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		if (detach !== false) this._fragment.u();
		this._fragment.d();
		this._fragment = null;
		this._state = {};
	}

	function destroyDev(detach) {
		destroy.call(this, detach);
		this.destroy = function() {
			console.warn('Component was already destroyed');
		};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				handler.__calling = true;
				handler.call(this, data);
				handler.__calling = false;
			}
		}
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._bind = options._bind;

		component.options = options;
		component.root = options.root || component;
		component.store = component.root.store || options.store;
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		this.root._lock = true;
		callAll(this.root._beforecreate);
		callAll(this.root._oncreate);
		callAll(this.root._aftercreate);
		this.root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function setDev(newState) {
		if (typeof newState !== 'object') {
			throw new Error(
				this._debugName + '.set was called without an object of data key-values to update.'
			);
		}

		this._checkReadOnly(newState);
		set.call(this, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	function _unmount() {
		if (this._fragment) this._fragment.u();
	}

	var protoDev = {
		destroy: destroyDev,
		get,
		fire,
		on,
		set: setDev,
		_recompute: noop,
		_set,
		_mount,
		_unmount,
		_differs
	};

	/* src/MenuItemIcon.html generated by Svelte v2.4.4 */

	function create_main_fragment(component, ctx) {
		var a, span, a_class_value, a_href_value;

		function select_block_type(ctx) {
			if (ctx.item.icon.svg) return create_if_block;
			if (ctx.item.icon.img) return create_if_block_1;
			return create_if_block_2;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				a = createElement("a");
				span = createElement("span");
				if_block.c();
				span.className = "icon";
				a.className = a_class_value = "menu-item " + ctx.item.active + " svelte-1dg4hzk";
				a.href = a_href_value = ctx.item.link;
			},

			m: function mount(target, anchor) {
				insertNode(a, target, anchor);
				appendNode(span, a);
				if_block.m(span, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.u();
					if_block.d();
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(span, null);
				}

				if ((changed.item) && a_class_value !== (a_class_value = "menu-item " + ctx.item.active + " svelte-1dg4hzk")) {
					a.className = a_class_value;
				}

				if ((changed.item) && a_href_value !== (a_href_value = ctx.item.link)) {
					a.href = a_href_value;
				}
			},

			u: function unmount() {
				detachNode(a);
				if_block.u();
			},

			d: function destroy$$1() {
				if_block.d();
			}
		};
	}

	// (3:4) {#if item.icon.svg}
	function create_if_block(component, ctx) {
		var text_value = ctx.item.icon.svg, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.item) && text_value !== (text_value = ctx.item.icon.svg)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	// (5:27) 
	function create_if_block_1(component, ctx) {
		var img, img_src_value, img_alt_value;

		return {
			c: function create() {
				img = createElement("img");
				img.src = img_src_value = ctx.item.icon.img;
				img.alt = img_alt_value = ctx.item.icon.name;
			},

			m: function mount(target, anchor) {
				insertNode(img, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.item) && img_src_value !== (img_src_value = ctx.item.icon.img)) {
					img.src = img_src_value;
				}

				if ((changed.item) && img_alt_value !== (img_alt_value = ctx.item.icon.name)) {
					img.alt = img_alt_value;
				}
			},

			u: function unmount() {
				detachNode(img);
			},

			d: noop
		};
	}

	// (7:4) {:else}
	function create_if_block_2(component, ctx) {
		var text_value = ctx.item.icon.name, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.item) && text_value !== (text_value = ctx.item.icon.name)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function MenuItemIcon(options) {
		this._debugName = '<MenuItemIcon>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('item' in this._state)) console.warn("<MenuItemIcon> was created without expected data property 'item'");

		this._fragment = create_main_fragment(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(MenuItemIcon.prototype, protoDev);

	MenuItemIcon.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/SideNav.html generated by Svelte v2.4.4 */



	function create_main_fragment$1(component, ctx) {
		var nav, a, img, img_src_value, a_href_value, text_1, ul, text_2, div, a_1, img_1, img_1_src_value, a_1_href_value;

		var each_value = ctx.menu;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		return {
			c: function create() {
				nav = createElement("nav");
				a = createElement("a");
				img = createElement("img");
				text_1 = createText("\n\t");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_2 = createText("\n\t");
				div = createElement("div");
				a_1 = createElement("a");
				img_1 = createElement("img");
				img.className = "img svelte-1omli4f";
				img.src = img_src_value = ctx.brand.img;
				img.alt = "Brand";
				a.className = "brand svelte-1omli4f";
				a.href = a_href_value = ctx.brand.link;
				ul.className = "menu svelte-1omli4f";
				img_1.className = "img svelte-1omli4f";
				img_1.src = img_1_src_value = ctx.user.img;
				img_1.alt = "User Settings";
				a_1.href = a_1_href_value = ctx.user.link;
				div.className = "user-menu bottom svelte-1omli4f";
				nav.className = "sidenav svelte-1omli4f";
			},

			m: function mount(target, anchor) {
				insertNode(nav, target, anchor);
				appendNode(a, nav);
				appendNode(img, a);
				appendNode(text_1, nav);
				appendNode(ul, nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				appendNode(text_2, nav);
				appendNode(div, nav);
				appendNode(a_1, div);
				appendNode(img_1, a_1);
			},

			p: function update(changed, ctx) {
				if ((changed.brand) && img_src_value !== (img_src_value = ctx.brand.img)) {
					img.src = img_src_value;
				}

				if ((changed.brand) && a_href_value !== (a_href_value = ctx.brand.link)) {
					a.href = a_href_value;
				}

				if (changed.menu) {
					each_value = ctx.menu;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = each_value.length;
				}

				if ((changed.user) && img_1_src_value !== (img_1_src_value = ctx.user.img)) {
					img_1.src = img_1_src_value;
				}

				if ((changed.user) && a_1_href_value !== (a_1_href_value = ctx.user.link)) {
					a_1.href = a_1_href_value;
				}
			},

			u: function unmount() {
				detachNode(nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}
			},

			d: function destroy$$1() {
				destroyEach(each_blocks);
			}
		};
	}

	// (6:2) {#each menu as item}
	function create_each_block(component, ctx) {
		var li;

		var menuitemicon_initial_data = { item: ctx.item };
		var menuitemicon = new MenuItemIcon({
			root: component.root,
			data: menuitemicon_initial_data
		});

		return {
			c: function create() {
				li = createElement("li");
				menuitemicon._fragment.c();
				setStyle(li, "--color", ctx.item.icon.color);
			},

			m: function mount(target, anchor) {
				insertNode(li, target, anchor);
				menuitemicon._mount(li, null);
			},

			p: function update(changed, ctx) {
				var menuitemicon_changes = {};
				if (changed.menu) menuitemicon_changes.item = ctx.item;
				menuitemicon._set(menuitemicon_changes);

				if (changed.menu) {
					setStyle(li, "--color", ctx.item.icon.color);
				}
			},

			u: function unmount() {
				detachNode(li);
			},

			d: function destroy$$1() {
				menuitemicon.destroy(false);
			}
		};
	}

	function get_each_context(ctx, list, i) {
		return assign(assign({}, ctx), {
			item: list[i],
			each_value: list,
			item_index: i
		});
	}

	function SideNav(options) {
		this._debugName = '<SideNav>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('brand' in this._state)) console.warn("<SideNav> was created without expected data property 'brand'");
		if (!('menu' in this._state)) console.warn("<SideNav> was created without expected data property 'menu'");
		if (!('user' in this._state)) console.warn("<SideNav> was created without expected data property 'user'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$1(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(SideNav.prototype, protoDev);

	SideNav.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/Banner.html generated by Svelte v2.4.4 */

	function create_main_fragment$2(component, ctx) {
		var div, img, img_src_value;

		return {
			c: function create() {
				div = createElement("div");
				img = createElement("img");
				img.src = img_src_value = ctx.banner.img;
				img.alt = "banner";
				setStyle(img, "width", "" + ctx.banner.width + "%");
				setStyle(img, "top", "" + ctx.banner.top + "%");
				setStyle(img, "left", "" + ctx.banner.left + "%");
				img.className = "svelte-n1ubcn";
				div.className = "banner svelte-n1ubcn";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(img, div);
			},

			p: function update(changed, ctx) {
				if ((changed.banner) && img_src_value !== (img_src_value = ctx.banner.img)) {
					img.src = img_src_value;
				}

				if (changed.banner) {
					setStyle(img, "width", "" + ctx.banner.width + "%");
					setStyle(img, "top", "" + ctx.banner.top + "%");
					setStyle(img, "left", "" + ctx.banner.left + "%");
				}
			},

			u: function unmount() {
				detachNode(div);
			},

			d: noop
		};
	}

	function Banner(options) {
		this._debugName = '<Banner>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('banner' in this._state)) console.warn("<Banner> was created without expected data property 'banner'");

		this._fragment = create_main_fragment$2(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Banner.prototype, protoDev);

	Banner.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/Sidebar.html generated by Svelte v2.4.4 */

	function create_main_fragment$3(component, ctx) {
		var aside, slot_content_header = component._slotted.header, slot_content_header_after, text, slot_content_default = component._slotted.default, slot_content_default_before;

		return {
			c: function create() {
				aside = createElement("aside");
				text = createText("\n\t");
				aside.className = "sidebar svelte-1ebnfi1";
			},

			m: function mount(target, anchor) {
				insertNode(aside, target, anchor);

				if (slot_content_header) {
					appendNode(slot_content_header, aside);
					appendNode(slot_content_header_after || (slot_content_header_after = createComment()), aside);
				}

				appendNode(text, aside);

				if (slot_content_default) {
					appendNode(slot_content_default_before || (slot_content_default_before = createComment()), aside);
					appendNode(slot_content_default, aside);
				}
			},

			p: noop,

			u: function unmount() {
				detachNode(aside);

				if (slot_content_header) {
					reinsertBefore(slot_content_header_after, slot_content_header);
				}

				if (slot_content_default) {
					reinsertAfter(slot_content_default_before, slot_content_default);
				}
			},

			d: noop
		};
	}

	function Sidebar(options) {
		this._debugName = '<Sidebar>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._slotted = options.slots || {};

		this.slots = {};

		this._fragment = create_main_fragment$3(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Sidebar.prototype, protoDev);

	Sidebar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/SidebarProfile.html generated by Svelte v2.4.4 */

	function create_main_fragment$4(component, ctx) {
		var header, slot_content_header = component._slotted.header, img, img_src_value, text, button, text_2, div, div_1, h2, text_4, p, text_5_value = ctx.user.followers, text_5, text_7, div_2, h2_1, text_9, p_1, text_10_value = ctx.user.following, text_10, text_13, div_3, h2_2, text_15, p_2, span_1, text_16_value = ctx.user.perf, text_16, text_17, span_2, text_18, text_19_value = ctx.user.reviews, text_19, text_20, text_24, main, slot_content_default = component._slotted.default, h2_3, text_26, div_4, text_27, h2_4, text_30, div_5;

		return {
			c: function create() {
				header = createElement("header");
				if (!slot_content_header) {
					img = createElement("img");
					text = createText("\n\t\t");
					button = createElement("button");
					button.innerHTML = "<span class=\"icon-follow\"></span>Follow";
					text_2 = createText("\n\t\t");
					div = createElement("div");
					div_1 = createElement("div");
					h2 = createElement("h2");
					h2.textContent = "Follower";
					text_4 = createText("\n\t\t\t\t");
					p = createElement("p");
					text_5 = createText(text_5_value);
					text_7 = createText("\n\t\t\t");
					div_2 = createElement("div");
					h2_1 = createElement("h2");
					h2_1.textContent = "Folowing";
					text_9 = createText("\n\t\t\t\t");
					p_1 = createElement("p");
					text_10 = createText(text_10_value);
					text_13 = createText("\n\t\t");
					div_3 = createElement("div");
					h2_2 = createElement("h2");
					h2_2.textContent = "Performance";
					text_15 = createText("\n\t\t\t");
					p_2 = createElement("p");
					span_1 = createElement("span");
					text_16 = createText(text_16_value);
					text_17 = createText(" ");
					span_2 = createElement("span");
					text_18 = createText("and ");
					text_19 = createText(text_19_value);
					text_20 = createText(" reviews");
				}
				text_24 = createText("\n\n");
				main = createElement("main");
				if (!slot_content_default) {
					h2_3 = createElement("h2");
					h2_3.innerHTML = "<span class=\"icon-camera\"></span> Projects";
					text_26 = createText("\n\t\t");
					div_4 = createElement("div");
					text_27 = createText("\n\t\t");
					h2_4 = createElement("h2");
					h2_4.innerHTML = "<span class=\"icon-star\"></span> Boosts <a class=\"right\" href=\"/\">More</a>";
					text_30 = createText("\n\t\t");
					div_5 = createElement("div");
				}
				if (!slot_content_header) {
					img.className = "profile-img img svelte-fs0esp";
					img.src = img_src_value = ctx.user.img;
					img.alt = "Profile Image";
					button.className = "btn svelte-fs0esp";
					h2.className = "svelte-fs0esp";
					p.className = "highlight info svelte-fs0esp";
					div_1.className = "col";
					h2_1.className = "svelte-fs0esp";
					p_1.className = "highlight info svelte-fs0esp";
					div_2.className = "col";
					div.className = "info row svelte-fs0esp";
					h2_2.className = "svelte-fs0esp";
					span_1.className = "highlight info svelte-fs0esp";
					span_2.className = "note";
					div_3.className = "col";
				}
				header.className = "svelte-fs0esp";
				if (!slot_content_default) {
					h2_3.className = "svelte-fs0esp";
					div_4.className = "tiles";
					h2_4.className = "svelte-fs0esp";
					div_5.className = "rows";
				}
			},

			m: function mount(target, anchor) {
				insertNode(header, target, anchor);
				if (!slot_content_header) {
					appendNode(img, header);
					appendNode(text, header);
					appendNode(button, header);
					appendNode(text_2, header);
					appendNode(div, header);
					appendNode(div_1, div);
					appendNode(h2, div_1);
					appendNode(text_4, div_1);
					appendNode(p, div_1);
					appendNode(text_5, p);
					appendNode(text_7, div);
					appendNode(div_2, div);
					appendNode(h2_1, div_2);
					appendNode(text_9, div_2);
					appendNode(p_1, div_2);
					appendNode(text_10, p_1);
					appendNode(text_13, header);
					appendNode(div_3, header);
					appendNode(h2_2, div_3);
					appendNode(text_15, div_3);
					appendNode(p_2, div_3);
					appendNode(span_1, p_2);
					appendNode(text_16, span_1);
					appendNode(text_17, p_2);
					appendNode(span_2, p_2);
					appendNode(text_18, span_2);
					appendNode(text_19, span_2);
					appendNode(text_20, span_2);
				}

				else {
					appendNode(slot_content_header, header);
				}

				insertNode(text_24, target, anchor);
				insertNode(main, target, anchor);
				if (!slot_content_default) {
					appendNode(h2_3, main);
					appendNode(text_26, main);
					appendNode(div_4, main);
					appendNode(text_27, main);
					appendNode(h2_4, main);
					appendNode(text_30, main);
					appendNode(div_5, main);
				}

				else {
					appendNode(slot_content_default, main);
				}
			},

			p: function update(changed, ctx) {
				if (!slot_content_header) {
					if ((changed.user) && img_src_value !== (img_src_value = ctx.user.img)) {
						img.src = img_src_value;
					}

					if ((changed.user) && text_5_value !== (text_5_value = ctx.user.followers)) {
						text_5.data = text_5_value;
					}

					if ((changed.user) && text_10_value !== (text_10_value = ctx.user.following)) {
						text_10.data = text_10_value;
					}

					if ((changed.user) && text_16_value !== (text_16_value = ctx.user.perf)) {
						text_16.data = text_16_value;
					}

					if ((changed.user) && text_19_value !== (text_19_value = ctx.user.reviews)) {
						text_19.data = text_19_value;
				}

				}
			},

			u: function unmount() {
				detachNode(header);

				if (slot_content_header) {
					reinsertChildren(header, slot_content_header);
				}

				detachNode(text_24);
				detachNode(main);

				if (slot_content_default) {
					reinsertChildren(main, slot_content_default);
				}
			},

			d: noop
		};
	}

	function SidebarProfile(options) {
		this._debugName = '<SidebarProfile>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('user' in this._state)) console.warn("<SidebarProfile> was created without expected data property 'user'");

		this._slotted = options.slots || {};

		this.slots = {};

		this._fragment = create_main_fragment$4(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SidebarProfile.prototype, protoDev);

	SidebarProfile.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/HeaderProfile.html generated by Svelte v2.4.4 */

	function setStars(node) {
		var stars = this.get().user.stars;
		for (var i=1; i<=stars; i++) {
			addStar('fullstar');
		}
		if (i !== stars) {
			addStar('halfstar');
			i += 1;
		}
		for (i; i<6; i++) {
			addStar();
		}
		function addStar(klass) {
			var star = document.createElement('span');
			if (klass) star.classList.add(klass);
			node.append(star);
		}
	}
	function create_main_fragment$5(component, ctx) {
		var div, h1, text_value = ctx.user.name, text, text_1, p, text_2_value = ctx.user.title, text_2, text_3, span, setStars_action, text_5, div_1;

		return {
			c: function create() {
				div = createElement("div");
				h1 = createElement("h1");
				text = createText(text_value);
				text_1 = createText("\n\t");
				p = createElement("p");
				text_2 = createText(text_2_value);
				text_3 = createText(" ");
				span = createElement("span");
				text_5 = createText("\n");
				div_1 = createElement("div");
				div_1.innerHTML = "<button><span class=\"icon-message\"></span></button>\n\t<button>Request</button>";
				h1.className = "svelte-198dwnh";
				span.className = "icon-stars";
				setStars_action = setStars.call(component, span) || {};
				div_1.className = "row";
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(h1, div);
				appendNode(text, h1);
				appendNode(text_1, div);
				appendNode(p, div);
				appendNode(text_2, p);
				appendNode(text_3, p);
				appendNode(span, p);
				insertNode(text_5, target, anchor);
				insertNode(div_1, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.user) && text_value !== (text_value = ctx.user.name)) {
					text.data = text_value;
				}

				if ((changed.user) && text_2_value !== (text_2_value = ctx.user.title)) {
					text_2.data = text_2_value;
				}
			},

			u: function unmount() {
				detachNode(div);
				detachNode(text_5);
				detachNode(div_1);
			},

			d: function destroy$$1() {
				if (typeof setStars_action.destroy === 'function') setStars_action.destroy.call(component);
			}
		};
	}

	function HeaderProfile(options) {
		this._debugName = '<HeaderProfile>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);
		if (!('user' in this._state)) console.warn("<HeaderProfile> was created without expected data property 'user'");

		this._fragment = create_main_fragment$5(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(HeaderProfile.prototype, protoDev);

	HeaderProfile.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/ProfileInfo.html generated by Svelte v2.4.4 */

	function create_main_fragment$6(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Profile info");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function ProfileInfo(options) {
		this._debugName = '<ProfileInfo>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$6(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProfileInfo.prototype, protoDev);

	ProfileInfo.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/ProfileFeed.html generated by Svelte v2.4.4 */

	function create_main_fragment$7(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("ProfileFeed");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function ProfileFeed(options) {
		this._debugName = '<ProfileFeed>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$7(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProfileFeed.prototype, protoDev);

	ProfileFeed.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/ProfileAgenda.html generated by Svelte v2.4.4 */

	function create_main_fragment$8(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Profile Agenda");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function ProfileAgenda(options) {
		this._debugName = '<ProfileAgenda>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$8(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProfileAgenda.prototype, protoDev);

	ProfileAgenda.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/ProfileResume.html generated by Svelte v2.4.4 */

	function create_main_fragment$9(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Profile Resume");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: noop,

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function ProfileResume(options) {
		this._debugName = '<ProfileResume>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$9(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProfileResume.prototype, protoDev);

	ProfileResume.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/ContentProfile.html generated by Svelte v2.4.4 */

	var components = {
	  ProfileInfo,
	  ProfileFeed,
	  ProfileAgenda,
	  ProfileResume
	};

	function data() {
	  return {
	    selected: ProfileFeed
	  }
	}
	var methods = {
	  toggleContent(i) {
	    var menu = this.get().menu;
	    var clicked = menu[i];
	    if (clicked.active) { return; }
	    var activeItem = menu.find(x => x.active === true);
	    activeItem.active = '';
	    clicked.active = true;
	    this.set({menu});
	    var selected = components[clicked.link];
	    if (selected) this.set({selected});
	  }
	};

	function create_main_fragment$10(component, ctx) {
		var nav, ul, text_1, div;

		var each_value = ctx.menu;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
		}

		var switch_value = ctx.selected;

		function switch_props(ctx) {
			return {
				root: component.root
			};
		}

		if (switch_value) {
			var switch_instance = new switch_value(switch_props(ctx));
		}

		return {
			c: function create() {
				nav = createElement("nav");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_1 = createText("\n\n");
				div = createElement("div");
				if (switch_instance) switch_instance._fragment.c();
				ul.className = "tab-nav svelte-1p1tmrf";
				div.className = "tab-content";
			},

			m: function mount(target, anchor) {
				insertNode(nav, target, anchor);
				appendNode(ul, nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				insertNode(text_1, target, anchor);
				insertNode(div, target, anchor);

				if (switch_instance) {
					switch_instance._mount(div, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.menu) {
					each_value = ctx.menu;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = each_value.length;
				}

				if (switch_value !== (switch_value = ctx.selected)) {
					if (switch_instance) switch_instance.destroy();

					if (switch_value) {
						switch_instance = new switch_value(switch_props(ctx));
						switch_instance._fragment.c();
						switch_instance._mount(div, null);
					}
				}
			},

			u: function unmount() {
				detachNode(nav);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}

				detachNode(text_1);
				detachNode(div);
			},

			d: function destroy$$1() {
				destroyEach(each_blocks);

				if (switch_instance) switch_instance.destroy(false);
			}
		};
	}

	// (3:4) {#each menu as item, i}
	function create_each_block$1(component, ctx) {
		var li, button, span, text_1, span_1, text_2_value = ctx.item.icon.text, text_2, button_class_value;

		function select_block_type(ctx) {
			if (ctx.item.icon.svg) return create_if_block$1;
			if (ctx.item.icon.img) return create_if_block_1$1;
			return create_if_block_2$1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				li = createElement("li");
				button = createElement("button");
				span = createElement("span");
				if_block.c();
				text_1 = createText("\n        ");
				span_1 = createElement("span");
				text_2 = createText(text_2_value);
				span.className = "icon";
				span_1.className = "text";

				button._svelte = { component, ctx };

				addListener(button, "click", click_handler);
				button.className = button_class_value = "menu-item " + (ctx.item.active ? 'active' : '') + " svelte-1p1tmrf";
				li.className = "svelte-1p1tmrf";
			},

			m: function mount(target, anchor) {
				insertNode(li, target, anchor);
				appendNode(button, li);
				appendNode(span, button);
				if_block.m(span, null);
				appendNode(text_1, button);
				appendNode(span_1, button);
				appendNode(text_2, span_1);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.u();
					if_block.d();
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(span, null);
				}

				if ((changed.menu) && text_2_value !== (text_2_value = ctx.item.icon.text)) {
					text_2.data = text_2_value;
				}

				button._svelte.ctx = ctx;
				if ((changed.menu) && button_class_value !== (button_class_value = "menu-item " + (ctx.item.active ? 'active' : '') + " svelte-1p1tmrf")) {
					button.className = button_class_value;
				}
			},

			u: function unmount() {
				detachNode(li);
				if_block.u();
			},

			d: function destroy$$1() {
				if_block.d();
				removeListener(button, "click", click_handler);
			}
		};
	}

	// (7:10) {#if item.icon.svg}
	function create_if_block$1(component, ctx) {
		var text_value = ctx.item.icon.svg, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.menu) && text_value !== (text_value = ctx.item.icon.svg)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	// (9:33) 
	function create_if_block_1$1(component, ctx) {
		var img, img_src_value, img_alt_value;

		return {
			c: function create() {
				img = createElement("img");
				img.src = img_src_value = ctx.item.icon.img;
				img.alt = img_alt_value = ctx.item.icon.name;
			},

			m: function mount(target, anchor) {
				insertNode(img, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.menu) && img_src_value !== (img_src_value = ctx.item.icon.img)) {
					img.src = img_src_value;
				}

				if ((changed.menu) && img_alt_value !== (img_alt_value = ctx.item.icon.name)) {
					img.alt = img_alt_value;
				}
			},

			u: function unmount() {
				detachNode(img);
			},

			d: noop
		};
	}

	// (11:10) {:else}
	function create_if_block_2$1(component, ctx) {
		var text_value = ctx.item.icon.name, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.menu) && text_value !== (text_value = ctx.item.icon.name)) {
					text.data = text_value;
				}
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	function get_each_context$1(ctx, list, i) {
		return assign(assign({}, ctx), {
			item: list[i],
			each_value: list,
			i: i
		});
	}

	function click_handler(event) {
		const { component, ctx } = this._svelte;

		component.toggleContent(ctx.i);
	}

	function ContentProfile(options) {
		this._debugName = '<ContentProfile>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data(), options.data);
		if (!('menu' in this._state)) console.warn("<ContentProfile> was created without expected data property 'menu'");
		if (!('selected' in this._state)) console.warn("<ContentProfile> was created without expected data property 'selected'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$10(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(ContentProfile.prototype, protoDev);
	assign(ContentProfile.prototype, methods);

	ContentProfile.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/SidebarContent.html generated by Svelte v2.4.4 */

	function create_main_fragment$11(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			u: noop,

			d: noop
		};
	}

	function SidebarContent(options) {
		this._debugName = '<SidebarContent>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign({}, options.data);

		this._fragment = create_main_fragment$11(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(SidebarContent.prototype, protoDev);

	SidebarContent.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/App.html generated by Svelte v2.4.4 */

	const USER = {
		img: '',
		banner: {
			img: 'https://i.imgur.com/MbMnM74.jpg',
			width: 130,
			top: -60,
			left: 0
		}
	};
	const PROFILE = {
		img: '',
		name: 'Mario Mendez',
		title: 'Senior Architect',
		stars: 5,
		followers: 320,
		following: 147,
		perf: 56,
		reviews: 42
	};

	const ICONS = [
					{name: 'search', color: '#42A5D2', url: '/'},
					{name: 'edit', color: '#FDAA29', url: '/'},
					{name: 'messages', color: '#F26C4F', url: '/'},
					{name: 'agenda', color: '#058E85', url: '/', 'text': 'Agenda'},
					{name: 'info', url: '', text: 'Info'},
					{name: 'feed', url: '', text: 'Feed'},
					{name: 'resume', url: '', text: 'Résumé'}
				];

	function data$1() {
		return {
			brand: {img: '', link: ''},
			icons: ICONS,
			mainNav: [
				{link: '', icon: 'search', active: true},
				{link: '', icon: 'edit'},
				{link: '', icon: 'messages'},
				{link: '', icon: 'agenda'}
			],
			user: USER,
			profileUser: PROFILE,
			profileMenu: [
				{link: 'ProfileInfo', icon: 'info'},
				{link: 'ProfileFeed', icon: 'feed', active: true},
				{link: 'ProfileAgenda', icon: 'agenda'},
				{link: 'ProfileResume', icon: 'resume'}
			]
		}
	}
	var methods$1 = {
		getIcons(menu) {
			var icons = this.get().icons;
			if (menu.length === 0) { return; }
			menu.forEach(item => {
				var found = icons.find(x => x.name === item.icon);
				if (found) item.icon = found;
				else item.icon = {name: item.icon};
			});
			return menu;
		}
	};

	function oncreate() {
		this.set({mainNav: this.getIcons(this.get().mainNav)});
		this.set({profileMenu: this.getIcons(this.get().profileMenu)});
	}
	function create_main_fragment$12(component, ctx) {
		var link, text, div, text_1, div_1, text_2, div_2, text_3, text_4, text_5, main, header, text_7, div_3, div_4, text_9, text_10, text_11;

		var sidenav_initial_data = {
		 	menu: ctx.mainNav,
		 	brand: ctx.brand,
		 	user: ctx.user
		 };
		var sidenav = new SideNav({
			root: component.root,
			data: sidenav_initial_data
		});

		var banner_initial_data = { banner: ctx.user.banner };
		var banner = new Banner({
			root: component.root,
			data: banner_initial_data
		});

		var sidebarprofile_initial_data = { user: ctx.profileUser };
		var sidebarprofile = new SidebarProfile({
			root: component.root,
			data: sidebarprofile_initial_data
		});

		var sidebar = new Sidebar({
			root: component.root,
			slots: { default: createFragment() }
		});

		var headerprofile_initial_data = { user: ctx.profileUser };
		var headerprofile = new HeaderProfile({
			root: component.root,
			data: headerprofile_initial_data
		});

		var contentprofile_initial_data = { menu: ctx.profileMenu };
		var contentprofile = new ContentProfile({
			root: component.root,
			data: contentprofile_initial_data
		});

		var sidebarcontent = new SidebarContent({
			root: component.root
		});

		var sidebar_1 = new Sidebar({
			root: component.root,
			slots: { default: createFragment() }
		});

		return {
			c: function create() {
				link = createElement("link");
				text = createText("\n\n");
				div = createElement("div");
				sidenav._fragment.c();
				text_1 = createText("\n\t");
				div_1 = createElement("div");
				banner._fragment.c();
				text_2 = createText("\n\t\t");
				div_2 = createElement("div");
				text_3 = createText("\n\t\t\t\t");
				sidebarprofile._fragment.c();
				text_4 = createText("\n\t\t\t");
				sidebar._fragment.c();
				text_5 = createText("\n\t\t\t");
				main = createElement("main");
				header = createElement("header");
				headerprofile._fragment.c();
				text_7 = createText("\n\t\t\t\t");
				div_3 = createElement("div");
				div_4 = createElement("div");
				contentprofile._fragment.c();
				text_9 = createText("\n\t\t\t\t\t");
				text_10 = createText("\n\t\t\t\t\t\t");
				sidebarcontent._fragment.c();
				text_11 = createText("\n\t\t\t\t\t");
				sidebar_1._fragment.c();
				link.href = "https://fonts.googleapis.com/css?family=Palanquin:300";
				link.rel = "stylesheet";
				header.className = "row vCentered svelte-cla1eg";
				div_4.className = "content svelte-cla1eg";
				div_3.className = "row";
				main.className = "svelte-cla1eg";
				div_2.className = "row";
				div_1.className = "scroll";
				div.className = "page sidenav svelte-cla1eg";
			},

			m: function mount(target, anchor) {
				appendNode(link, document.head);
				insertNode(text, target, anchor);
				insertNode(div, target, anchor);
				sidenav._mount(div, null);
				appendNode(text_1, div);
				appendNode(div_1, div);
				banner._mount(div_1, null);
				appendNode(text_2, div_1);
				appendNode(div_2, div_1);
				appendNode(text_3, sidebar._slotted.default);
				sidebarprofile._mount(sidebar._slotted.default, null);
				appendNode(text_4, sidebar._slotted.default);
				sidebar._mount(div_2, null);
				appendNode(text_5, div_2);
				appendNode(main, div_2);
				appendNode(header, main);
				headerprofile._mount(header, null);
				appendNode(text_7, main);
				appendNode(div_3, main);
				appendNode(div_4, div_3);
				contentprofile._mount(div_4, null);
				appendNode(text_9, div_3);
				appendNode(text_10, sidebar_1._slotted.default);
				sidebarcontent._mount(sidebar_1._slotted.default, null);
				appendNode(text_11, sidebar_1._slotted.default);
				sidebar_1._mount(div_3, null);
			},

			p: function update(changed, ctx) {
				var sidenav_changes = {};
				if (changed.mainNav) sidenav_changes.menu = ctx.mainNav;
				if (changed.brand) sidenav_changes.brand = ctx.brand;
				if (changed.user) sidenav_changes.user = ctx.user;
				sidenav._set(sidenav_changes);

				var banner_changes = {};
				if (changed.user) banner_changes.banner = ctx.user.banner;
				banner._set(banner_changes);

				var sidebarprofile_changes = {};
				if (changed.profileUser) sidebarprofile_changes.user = ctx.profileUser;
				sidebarprofile._set(sidebarprofile_changes);

				var headerprofile_changes = {};
				if (changed.profileUser) headerprofile_changes.user = ctx.profileUser;
				headerprofile._set(headerprofile_changes);

				var contentprofile_changes = {};
				if (changed.profileMenu) contentprofile_changes.menu = ctx.profileMenu;
				contentprofile._set(contentprofile_changes);
			},

			u: function unmount() {
				detachNode(link);
				detachNode(text);
				detachNode(div);
			},

			d: function destroy$$1() {
				sidenav.destroy(false);
				banner.destroy(false);
				sidebarprofile.destroy(false);
				sidebar.destroy(false);
				headerprofile.destroy(false);
				contentprofile.destroy(false);
				sidebarcontent.destroy(false);
				sidebar_1.destroy(false);
			}
		};
	}

	function App(options) {
		this._debugName = '<App>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(data$1(), options.data);
		if (!('mainNav' in this._state)) console.warn("<App> was created without expected data property 'mainNav'");
		if (!('brand' in this._state)) console.warn("<App> was created without expected data property 'brand'");
		if (!('user' in this._state)) console.warn("<App> was created without expected data property 'user'");
		if (!('profileUser' in this._state)) console.warn("<App> was created without expected data property 'profileUser'");
		if (!('profileMenu' in this._state)) console.warn("<App> was created without expected data property 'profileMenu'");

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$12(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(App.prototype, protoDev);
	assign(App.prototype, methods$1);

	App.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	var app = new App({
		target: document.body,
		data: {}
	});

	return app;

}());
//# sourceMappingURL=bundle.js.map
